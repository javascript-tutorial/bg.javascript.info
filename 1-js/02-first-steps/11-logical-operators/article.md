# Логически оператори

Има три логически оператора в JavaScript: `||` (ИЛИ), `&&` (И), `!` (НЕ / ОТРИЦАНИЕ).

Въпреки че им се вика "логически" оператори, те могат да бъдат приложени към стойности от всякакъв тип, а не само булеви. Резултатът им може да бъде от всякакъв тип.

Нека да видим подробностите.

## || (ИЛИ)

Операторът "ИЛИ" е представена с два вертикална линии:

```js
result = a || b;
```

При класическото програмиране логическото "ИЛИ" е предназначено да манипулира само булевите стойности. Ако някой от аргументите му е `true`, се връща `true`, в противен случай се връща `false`.

В JavaScript операторът е малко по-сложен и по-мощен. Но първо, нека да видим какво се случва с булевите стойности.

Има четири възможни логически комбинации:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Както виждаме, резултатът винаги е `true` с изключение на случая, когато и двата операнда са `false`.

Ако операндът не е булев, той се превръща в булев за оценка.

Например, цифрата `1` се третира като `true`, а цифрата `0` като `false`:

```js run
if (1 || 0) { // работи точно като if (true || false)
  alert( 'truthy!' );
}
```

В повечето време, ИЛИ `||` се използва в `if`, за да тестваме дали някое от дадените условия са `true`.

Например:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офисът е затворен.' );
}
```

Можем да подадем повече условия:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офисът е затворен.' ); // това е уикендът
}
```

## ИЛИ "||" намира първата истинска стойност

Описаната по-горе логика е донякъде класическа. Сега, нека да внесем "допълнителни" функции на JavaScript.

Разширеният алгоритъм работи както следва.

Дадени са множество ИЛИ стойности:

```js
result = value1 || value2 || value3;
```

ИЛИ `||` операторът прави точно следното:

- Оценява операндите отляво надясно.
- Превръща всеки операнд в неговата булева стойност. Ако резултатът е `true`, спира и връща първоначалната стойност на този операнд.
- Ако всички операнди са оценени (т.е. всички са `false`) връща последния операнд.

Стойността се връща в първоначалния си вид, без да се преобразува.

С други думи, верига от ИЛИ `"||"` пръща първата вярна стойност или последната ако не е намерена вярна такава.

Например:

```js run
alert( 1 || 0 ); // 1 (1 е вярна)

alert( null || 1 ); // 1 (1 е първата вярна стойност)
alert( null || 0 || 1 ); // 1 (първата вярна стойност)

alert( undefined || null || 0 ); // 0 (всичките са неверни, връща последната стойност)
```

Това води до интересно използване в сравнение с a "чист, класически, само булева "ИЛИ"".

1. **Получаване на първата вярна стойност от списък на променливи или изрази.**

    Например, да имаме следните променливи: `firstName`, `lastName` и `nickName`.

    Нека да използваме ИЛИ `||` да изберем този, който има данните и да го покажем (или `anonymous` ако нищо не е зададено):

    ```js run
    let firstName = "";
    let lastName = "";
    let nickName = "SuperCoder";

    *!*
    alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
    */!*
    ```

  Ако всички променливи бяха лъжливи, щеше да се появи `Anonymous`.

2. **Оценка на "късо съединение."**

    Друга характеристика на ИЛИ `||` оператора е така нареченият оценка на "късо съединение.".

    Означава, че `||` обработва своите аргументи, докато не се достигне първата вярна стойност, и след това стойността се връща веднага, без да докосва останалите аргументи.

    Важността на тази функция става очевидно, ако операндът не е просто стойност, а израз със страничен ефект, като присвояване на променлива или извикване на функция.

    В примера по-долу се отпечатва само второто съобщение:

    ```js run no-beautify
    *!*true*/!* || alert("не се показва");
    *!*false*/!* || alert("се показва");
    ```

    В първия ред, ИЛИ `||` операторът спира оценката веднага след като види `true`, така че `alert` не се изпълнява.

    Понякога хората използват тази функция, за да изпълняват команди, само ако състоянието в лявата част е не вярна.

## && (И)

Операторът "И" се представлявана със двата съмвола `&&`:

```js
result = a && b;
```

В класическото програмиране, "И" връща `true` ако и двата операнда са верни, а `false` в противен случай:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Пример с `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Времето е 12:30' );
}
```

Както и с "ИЛИ", всяка стойност е разрешена като операнд на "И":

```js run
if (1 && 0) { // оценява се като true && false
  alert( "няма да работи, защото резултатът е не вярна" );
}
```


## И "&&" операторът намира първата не вярна стойност

Дадени са множество стойности на "И" оператора:

```js
result = value1 && value2 && value3;
```

"И" `&&` операторът прави следното:

- Оценява операндите отляво надясно.
- Всеки операнд го преобразува в булев. Ако резултатът е `false`, спира и връща първоначалната стойност на този операнд.
- Ако всички операнди са оценени (т. е. всички бяха верни), връща последния операнд.

С други думи, "И" връща първата не вярна стойност или последната стойност, ако няма намерена такава.

Правилата по-горе са подобни на "ИЛИ". Разликата е в, това че "И" връща първата *не вярна* стойност докато "ИЛИ" връща първата *вярна* стойност.

Примери:

```js run
// ако първият операнд е верен,
// "И" връща втория операнд:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Ако първият операнд е не вярна,
// "И" го връща. Вторият операнд се игнорира
alert( null && 5 ); // null
alert( 0 && "без значение какво" ); // 0
```

Също така можем да предадем няколко стойности подред. Вижте как се връща първата не вярна:

```js run
alert( 1 && 2 && null && 3 ); // null
```

Когато всички стойности са верни, се връща последната стойност:

```js run
alert( 1 && 2 && 3 ); // 3, последният
```

````smart header="Precedence of AND `&&` is higher than OR `||`"
Предимството на "И" `&&` е по-голямо от "ИЛИ" `||`.

Така че кодът `a && b || c && d` е по същество същото, както ако `&&` изразите бяха в скоби: `(a && b) || (c && d)`.
````

````warn header="Don't replace `if` with || or &&"
<<<<<<< HEAD
Понякога, хората използват "И" `&&` оператора като "съкратен начин за писане на `if`".
=======
Sometimes, people use the AND `&&` operator as a "shorter way to write `if`".
>>>>>>> 58f6599df71b8d50417bb0a52b1ebdc995614017

Например:

```js run
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```

Действието в дясната част на `&&` би се изпълнила само ако оценката я достигне. Тоест, само ако `(x > 0)` е `true`.

Така че ние в общи линии имаме аналог:

```js run
let x = 1;

if (x > 0) alert( 'По-голям от нула!' );
```

Въпреки че, вариантът с `&&` изглежда по-къса, `if` е по-очевидна и има тенденция да бъде малко по-четлива. Затова препоръчваме да използвате всяка конструкция за нейната цел.
````


## ! (НЕ / ОТРИЦАНИЕ)

Булевата "НЕ" оператор е представена с удивителен знак `!`.

Синтаксисът е доста прост:

```js
result = !value;
```

Операторът приема един аргумент и прави следното:

1. Преобразува операнда в булев тип: `true/false`.
2. Връща обратната стойност.

Например:

```js run
alert( !true ); // false
alert( !0 ); // true
```

Двойно "НЕ" `!!` понякога се използва за преобразуване на стойност в булев тип:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

Това е, първия "НЕ" преобразува стойността в булева и връща обратната, а вторият "НЕ" го обръща отново. В крайна сметка имаме обикновена стойност-към-булева превръщане.

Има малко по-подробен начин да направите същото -- вградената `Boolean` функция:

```js run
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

Приоритетът на "НЕ" `!` е най-високият от всички логически оператори, така че винаги се изпълнява първи, преди `&&` или `||`.
