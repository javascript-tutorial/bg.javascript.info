# Функции

Често ни се налага да извършваме сходни действия на много места в нашия код.

Например, искаме да покажем добре изглеждащо съобщение, когато визитор се логне, излезе или може би някъде другаде.
Функциите са главните "строителни блокове" на програмата. Те позволяват кода да бъде изпълнен много пъти без повторение.

Вече видяхме примери за вградени функции като `alert(message)`, `prompt(message, default)` и `confirm(question)`. Но ние също можем да създаваме функции.

## Декларация на функция

За да създадем функция използваме _декларация на функция_.

Изглежда така:

```js
function showMessage() {
  alert("Здравейте всички!");
}
```

Ключовата дума `function` е първа, следвана от името *на функцията*, след това лист от *параметри* между скобите (разделени от запетаи, празно в примера по-горе, ще видим примери по-късно) и най-накрая кода на функцията, познат още като "тяло на функцията", между "{}" скобите.

```js
function name(parameter1, parameter2, ... parameterN) {
 // body
}
```

Нашата нова функция може да бъде извикана по име: `showMessage()`.

Например:

```js run
function showMessage() {
  alert( 'Здравейте всички' );
}

*!*
showMessage();
showMessage();
*/!*
```

Името на функцията `showMessage()` изпълнява кода. Тук ще видим съобщението два пъти.

Примерът ясно демонстрира една от главните цели на функцията: да избегнем дупликации на кода.

Ако някога трябва да сменим съобщението или начина по който се показва, достатъчно е да сменим кода на едно място: функцията, която го изпълнява.

## Локални вариации

Вариация декларирана във функцияата е видима единствено вътре във функцията.

Като например:

```js run
function showMessage() {
*!*
  let message = "Здравей, аз съм JavaScript!"; // локална вариация
*/!*

  alert( message );
}

showMessage(); // Здравей, аз съм JavaScript!

alert( message ); // <-- Грешка! Вариацията е локална във функцията
```

## Външни вариации

Функцията също може да има достъп до външна вариация, като например:

```js run no-beautify
let *!*userName*/!* = 'Джон';

function showMessage() {
  let message = 'Здравей, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Здравей, Джон
```

Функцията има пълен достъп до външната вариация. Също така може да я модифицира.

Като например:

```js run
let *!*userName*/!* = 'Джон';

function showMessage() {
  *!*userName*/!* = "Боб"; // (1) промени външната вариация

  let message = 'Здравей, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*Джон*/!* преди изпълнението на функцията

showMessage();

alert( userName ); // *!*Боб*/!*, стойността беше модифицирана от функцията
```

Външната вариация се изпълнява само, ако няма локална такава.

Ако вариация със същото име е декларирана във функцията, то тогава _засенчва_ външната. Като например, в кода по-долу функцията използва локалната `userName`. Външната е игнорирана:

```js run
let userName = 'Джон';

function showMessage() {
*!*
  let userName = "Боб"; // декларира локална вариация
*/!*

  let message = 'Hello, ' + userName; // *!*Боб*/!*
  alert(message);
}

// Функцията ще създаде и използва своя собствена userName
showMessage();

alert( userName ); // *!*Джон*/!*, непроменена, функцията нямаше достъп до външната вариация
```

```smart header="Глобални вариации"
Вариации декларирани извън функции, като външната `userName` в кода по-горе, се наричат *глобални*.

Глобалните вариации са видими от всички функции (ако не са засенчени от локалните вариации).

Добра практика е да се миниманизира използването на глобални вариации. Модерният код има малко на брой глобални вариации или те въобще отсъстват. Повечето вариации са декларирани в свои собствени функции. Понякога обаче, те могат да са полезни да сухраняват проекционни данни.
```

## Параметри

Можем да задаваме произволни данни на функции изполвайки параметри.

В примера по-долу, фукнцията има два параметъра: `from` и `text`.

```js run
function showMessage(*!*from, text*/!*) { // аргументи: from, text
  alert(from + ': ' + text);
}

*!*
showMessage('Ани', 'Здравей!'); // Ани: Здравей! (*)
showMessage('Ани', "Как е?"); // Ани: Как е? (**)
*/!*
```

Когато функцията е изпълнена в редовете `(*)` и `(**)`, дадените стойности са копирани в локалните вариации `from` и `text`. Функцията ги използва.

Ето още един пример: имаме вариация `from` и я предаваме на функцията. Забележи: функцията променя `from`, но промяната не е видима извън нея, защото функцията винаги получава копие от стойността:

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // прави "from" да изглежда по-добре
*/!*

  alert( from + ': ' + text );
}

let from = "Ани";

showMessage(from, "Здравей"); // *Ани*: Здравей

// стойността на "from" е същата, функцията модифицира локалното копие
alert( from ); // Ани
```

Когато дадена стойност е подадена като параметър на функцията, то също се нарича и *аргумент*.

<<<<<<< HEAD
С други думи, да кажем правилно тези термини:
=======
- A parameter is the variable listed inside the parentheses in the function declaration (it's a declaration time term).
- An argument is the value that is passed to the function when it is called (it's a call time term).
>>>>>>> bf7d8bb1af3b416d393af1c15b03cb1352da1f9c

- Параметърът е променливата, посочена в скобите в декларацията на функцията (член при декларацията)
- Аргумент е стойността, която се предава на функцията, когато е извикана (член при извикване).

Декларираме функции, изброявайки техните параметри, след което ги извикваме предавайки аргументи.

В горния пример може да се каже че: "функцията `showMessage` е декларирана с два параметъра, а след това е извикана с два аргумента: `from` и `"Hello"`".

## Стойности по подразбиране

Ако не е предоставен параметър, то тогава неговата стойност става `undefined`.

Като например, познатата ни вече функция `showMessage(from, text)` може да бъде извикана с един единствен аргумент:

```js
showMessage("Ани");
```

Това не е грешка. Подобно изпълнение ще покаже `"Ани: undefined"`. Тъй като стойността на параметъра `text` не е подаден, затова се връща `undefined`.

Можем да посочим т.нар "стойност по подразбиране" (да се използва, ако е пропуснато) за параметъра във декларацията на функцията използвайки `=`:

```js run
function showMessage(from, *!*text = "не е зададен текст"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ани"); // Ани: не е зададен текст
```

<<<<<<< HEAD
Сега ако параметърът на `text` не е зададен, ще получи стойността `"не е зададен текст"`
=======
Now if the `text` parameter is not passed, it will get the value `"no text given"`.

The default value also jumps in if the parameter exists, but strictly equals `undefined`, like this:

```js
showMessage("Ann", undefined); // Ann: no text given
```
>>>>>>> bf7d8bb1af3b416d393af1c15b03cb1352da1f9c

Тук `"не е зададен текст"` е стринг, но може да бъде по-сложен израз, който е единствено изчислен и възложен ако параматърът. Така че, това също е възможно:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() изпълнява се само, ако не е зададен текст
  // резултатът му става стойността на text
}
```

```smart header="Оценяване на параметрите по подразбиране"
При JavaScript, параметър по подразбиране се оценява всеки път, когато функцията е извикана без ресяективния параметър.

В примера по-горе, `anotherFunction()` не се извиква изобщо, ако параметърът `text` е подаден.

С други думи, той се извиква независимо всеки път, когато липсва `text`.
```

<<<<<<< HEAD
### Алтернативни параметри по подразбиране

Понякога има смисъл да задавате стойности по подразбиране за параметри не при деклараране на функциите, а на по-късен етап.
=======
````smart header="Default parameters in old JavaScript code"
Several years ago, JavaScript didn't support the syntax for default parameters. So people used other ways to specify them.

Nowadays, we can come across them in old scripts.

For example, an explicit check for `undefined`:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'no text given';
  }
*/!*

  alert( from + ": " + text );
}
```

...Or using the `||` operator:

```js
function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
```
````


### Alternative default parameters

Sometimes it makes sense to assign default values for parameters at a later stage after the function declaration.
>>>>>>> bf7d8bb1af3b416d393af1c15b03cb1352da1f9c

Можем да проверим дали параметърът е подаден по време на изпълнението на функцията, като го сравним с `undefined`:

```js run
function showMessage(text) {
  // ...

*!*
  if (text === undefined) { // ако параметърът липсва
    text = 'празно съобщение';
  }
*/!*

  alert(text);
}

showMessage(); // празно съобщение
```

...Иначе бихме могли да използваме оператора `||`:

```js
// ако 'text' e 'undefined' или невярно, задайте го на 'empty'
function showMessage(from, text) {
  text = text || 'празен';
  ...
}
```

Съвременните JavaScript двигатели поддържат [нулевия условен оператор](info:nullish-coalescing-operator) `??`, по-добре е, когато неверните стойности, като '0', се считат за "нормални":

```js run
function showCount(count) {
  // ако "count" е "undefined" или "null", покажете "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

### Връщане на стойност

Функция може да върне стойност в кода при извикване като резултат.

Най-простия пример би бил функция, която събира две стойности:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Директивата `return` може да бъде на всяко място във функцията. Когато функцията я достигне, функцията спира и стойността се връща в кода на повикване (зададена на `result` по-горе).

Възможно е да има много повторения на `return` в една единствена функция. Например:

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('Имаш ли разрешение от родителите?');
*/!*
  }
}

let age = prompt('На колко години си?', 18);

if ( checkAge(age) ) {
  alert( 'Получен достъп' );
} else {
  alert( 'Отказан достъп' );
}
```

Възможно е да използваме `return` без стойност. Това кара да излезем от функцията веднага.

Например:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "Показва ти филма" ); // (*)
  // ...
}
````

В кода по-горе, ако `checkAge(age)` върне `false`, тогава `showMovie` няма да продължи към `alert`.

````smart header="Функция с празен `return` или с липсващ такъв връща `undefined`"
Ако функция не върне стойност, е същото ако върне `undefined`:

```js run
function doNothing() {
  /* празно */
}

alert(doNothing() === undefined); // true
```

Празен `return` е също като `return undefined`:

```js run
function doNothing() {
  return;
}

alert(doNothing() === undefined); // true
````


````warn header="Никога не слагайте нов ред между `return` и стойността"
При дълъг израз в `return`, може да е изкушаващо да го разделим на отделен ред, ето така:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
Това не работи, защото JavaScript предполага точка и запетая ";" след `return`. Това работи също като:

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

Което автоматично се превръща в празен "return".

Ако искаме да върнем израз в няколко реда, трябва да го започнем в същия ред като `return`. Или поне да сложим отварящата скоба на същия ред:

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
Това ще работи точно както очакваме.
````

## Именуване на функция [#function-naming]

Функциите са действия. Така че техните имена са обикновенно глаголи. Трябва да са кратки, възможно най-акуратни и описващи какво прави функцията, така че някой четящ кода получава индикация за дейността на функцията.

Общоприета практика е да започнем функция с глаголен префикс който описва действието. Трябва да има съгласие в екипа в това какво означават префиксите.
Например, функции които започват с `"show"` обикновенно показват нещо.

Функции започващи с...

- `"get…"` -- връщат стойност,
- `"calc…"` -- изчисляват нещо,
- `"create…"` -- създават нещо,
- `"check…"` -- проверяват нещо и връщат булева, и т.н.

Примери за такива имена:

```js no-beautify
showMessage(..)     // показва съобщение
getAge(..)          // връща годините (получава ги някакси)
calcSum(..)         // калкулира сбора и връща резултата
createForm(..)      // създава форма (и обикновенно я връща)
checkPermission(..) // проверява достъп, връща true/false
```

С префикси, един поглед на името на функцията дава да се разбере каква работа извършва и какъв тип стойност връща.

```smart header="Една функция -- едно действие"
Функция трябва да прави точно това, което показва името, не повече.

Две различни действия обикновенно заслужават две функции, дори когато те нормално са извиквани заедно (в този случай можем да създадем трета функция, която извиква двете).

Няколко примера на нарушаване на правилото:

- `getAge` -- ще бъде лошо, ако покаже `alert` с годините (трябва само да ги получи).
- `createForm` -- ще е лошо, ако модифицира документа, добавяйки форма (трябва само да я създаде и върне).
- `checkPermission` -- ще е лошо, ако покаже `access granted/denied` съобщение (трябва само да извърши проверката и върне резултата).

Тези примери очакват често срещани значения на префиксите. Ти и твоя екип сте свободни да се съгласите на значение, но нормални те не са много различни. Във всеки случай, трябва да имаш общо разбиране на това какво означават префиксите, какво префиксите на функциите могат и не могат да правят. Всички функции с общи префикси трябва да спазват правилата. И екипът трябва да се съгласува.
```

```smart header="Ултра-кратки имена на функции"
Функции, които се изпълняват много често понякога имат ултра-кратки имена.

Например, [jQuery](http://jquery.com) структурата дефинира функция с `$`. [Lodash](http://lodash.com/) библиотеката име своя собствена вътрешна функция с име `_`.

Има изключения. Като цяло името на функцията трябва да е сбито и описателно.
```

## Функции == Коментари

Функциите трябва да са кратки и да правят само едно нещо. Ако това нещо е голямо, може би си заслужава да разделим функцията на няколко по-кратки. Понякога следването на това правило може да не е лесно, но определено е нещо хубаво.

Отделна функция е не само по-лесно да бъде тествана и отстранени грешките -- самото и съществуване е страхотен коментар!

Например, сравни двете функции `showPrimes(n)` по-долу. Всяка произвежда [prime numbers](https://en.wikipedia.org/wiki/Prime_number) до `n`.

Първият вариант използва етикет:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i); // a prime
  }
}
```

Вторият вариант използва допълнителна функция `isPrime(n)` да тества за основа:

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

Вторият вариан е по-лесен за разбиране, нали? Вместо част от кода ние виждаме име на действието (`isPrime`). Понякога хората наричат такъв код _self-describing_ (самоописващ).

Така че функциите могат да бъдат създадени, дори когато не възнамеряваме да ги използваме отново. Те структурират кода и го правят по-лесен за четене.

## Обобщение

Декларация на функция изглежда така:

```js
function name(parameters, delimited, by, comma) {
  /* код */
}
```

- Стойности зададени на функция като параметри се копират в нейните локални вариации.
- Функция може да има достъп до други външни вариации. Но работи само отвътре навън. Кодът извън функцията не вижда нейните локални вариации.
- Функция може да върне стойност. Ако не го направи, тогава резултатът е `undefined`.

За да направим кога чист и лесен за разбиране, препоръчително е да използаме главно локални вариации и параметри във функцията, не външни вариации.

<<<<<<< HEAD
Винаги е по-лесно да разберем функция, която получава параметри, разботи с тях и връща резултат от функция, която не получава параметри, но модифицира външни вариации, като страничен ефект.
=======
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.
>>>>>>> bf7d8bb1af3b416d393af1c15b03cb1352da1f9c

Именуване на функциите:

- Името трябва да описва ясно какво прави функцията. Когато видим извикване на функция в кода, добро име веднага ни дава да разберем какво прави и какво връща.
- Функцията е действие, така че имената на функциите са обикновено глаголи.
- Съществуват много добре известни префикси на функции като `create…`, `show…`, `get…`, `check…` и т.н. Използвай ги, за да подскажеш какво прави функцията.

Функциите да главните строителни болкове на скрипта. Сега ние се запознаваме с основното, така че да можем да започнем да ги създаваме и използваме. Но това е само началото на пътя. Ние ще се връщаме към тях много пъти, като се задълбочаваме в тяхните разширени функции.
