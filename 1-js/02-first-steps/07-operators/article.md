# Оператори

Познаваме много оператори още от училище. Те са знаците като събиране `+`, умножение `*`, изваждане `-` и т.н.

В тази глава ще се съсредоточим върху аспекти на операторите, които не са обхванати от училищната аритметика.

## Термини: "едноаргументен", "двуаргументен", "операнд"

Преди да продължим, нека да разберем някои общи термини.

- *Операнд* -- е това, към което се прилагат операторите. Например, в умножението `5 * 2` има два операнда: левият операнд `5` и десният операнд `2`. Понякога хората ги наричат "аргументи" вместо "операнди".
- Един оператор е *едноаргументен* ако има само един операнд. Например, едноаргументен минус `-` обръща знака на числото:

    ```js run
    let x = 1;

    *!*
    x = -x;
    */!*
    alert( x ); // -1, приложен е едноаргументен минус
    ```
- Един оператор е *двуаргументен* ако има два операнда. Същият минус съществува и в двуаргументен вариянт:

    ```js run no-beautify
    let x = 1, y = 3;
    alert( y - x ); // 2, приложен е двуаргументен минус
    ```

    Формално в примерите по-горе имаме два различни оператора, които споделят един и същ символ: оператора за отрицание, едноаргументен оператор, който обръща знака на число, и оператора за изваждане, двуаргументен оператор, който изважда едно число от друго.

## Свързване на символни низове(текст), двуаргументен +

Сега, нека да разгледаме някои специални функции на JavaScript операторите, които са извън училищната аритметика.

Обикновено, оператора плюс `+` събира числа.

Но, ако двуаргоментниият плус `+` се използва със символни низове(текст), то ги слива(обединява):

```js
let s = "моят" + "текст";
alert(s); // моят текст
```

Забележете, че ако един от аргументите е символен низ(текст), то и другият аргумент е преобразуван в такъв.

Например:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Забележете, няма значение дали първият аргумент е символен низ(текст) или вторият. Правилото е просто: ако един от аргументите е символен низ(текст), то и другият също е преобразуван в символен низ(текст).

Имайте предвид обаче, че операциите се изпълняват от ляво на дясно. Ако има две числа, последвани от символен низ(текст), числата ще бъдат събрани, преди да бъдат преобразувани в символен низ(текст):

```js run
alert(2 + 2 + '1' ); // "41",а не "221"
```

Свързване на символни низове(текст) и преобразуването в такива е особеност на двуаргоментния плюс `+`. Другите аритметични оператори работят само с числа и винаги преобразуват своите аргументи в такива.

Например, изваждане и делене:

```js run
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

## Преобразуване в число, едноаргументен +

Плюсът `+` има две форми: двуаргументна форма, която разгледахме по-горе, и едноаргументна форма.

Едноаргументният плус, или с други думи, операторът плус `+` приложен към един аргумент, не прави нищо, когато е приложен към число. Но ако аргумента не е число, едноаргументният плус преобразува този аргумент в такова.

Например:

```js run
// Няма ефект в/у числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// Преобразува в числови стойности
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

Всъщност, прави същото нещо като функцията `Number(...)`, но е по-кратък.

Необходимостта от преобразуването на символни низове(текст) в числа възниква много често. Например, когато получаваме стойности от полетата на форма в HTML, те обикновено са под формата на символен низ(текст). Ами ако искаме да ги съберем?

 Двуаргоментният плюс ще ги свърже в символен низ(текст):

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", Двуаргоментният плюс свързва символни низизове(текст)
```

Ако искаме да ги използваме като числа, ние трябва да ги преобразуваме в такива и след това да ги съберем:

```js run
let apples = "2";
let oranges = "3";

*!*
// и двете стойности са конвертиррани в числа, преди да използваме двуаргоментен плюс
alert( +apples + +oranges ); // 5
*/!*

// по-дългият вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

От математическа гледна точка, изобилието от плюсове може да изглежда странно. Но от гледна точка на програмист, няма нищо странно: едноаргументните плюсове са приложени първи, те преобразувант символните низове(текст) в числа, а след това двуаргументният плус ги събира.

А защо едноаргументните плюсове се прилагат към аргументите пред двуаргументният? Както ще видим, това е заради тяхното по-голямо  *предимство*.

## Предимство на операторите

Ако в един израз има повече от един оператор, реда на тяхното изпълнение се определя от тяхното *предимство*, или с други думи, приоритета на операторите по подразбиране.

Още от училище всички знаем, че умножението в израза `1 + 2 * 2` трябва да се изчисли преди събирането. Точно това означава предимството. Посочено е, че умножението има *по-голям приоритет* от събирането.

Скобите отменят всяко предимство, така че ако не сме доволни от подредбата по подразбиране, можем да ги използваме, за да я променим. Например, можем да напишем `(1 + 2) * 2`.

Има много оператори в JavaScript. Всеки оператор има съответен приоритет. Този с по-голям приоритет се изпълнява първи. Ако приоритетът е равен, изпълнението е от ляво на дясно.

Ето извадка от [таблицата за предимство](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence) (няма нужда да помните това, но имайте предвид, че едноаргументните оператори са с по-висок приоритет от съответните двуаргументни):

| Предимство | Име | Знак |
|------------|------|------|
| ... | ... | ... |
<<<<<<< HEAD
| 16 | едноаргументен плюс | `+` |
| 16 | едноаргументен минус | `-` |
| 14 | умножение | `*` |
| 14 | делене | `/` |
| 13 | събиране | `+` |
| 13 | изваждане | `-` |
=======
| 17 | unary plus | `+` |
| 17 | unary negation | `-` |
| 15 | multiplication | `*` |
| 15 | division | `/` |
| 13 | addition | `+` |
| 13 | subtraction | `-` |
>>>>>>> 9acc1302a14a3bbabbc9bf95d04581094bd0f1a8
| ... | ... | ... |
| 3 | присвояване | `=` |
| ... | ... | ... |

Както можем да видим, "едноаргументният плюс" има приоритет `16`, който е по-висок от `13`, този на "събиране" (двуаргументният плюс). Ето защо, в израза `"+apples + +oranges"`, едноаргументният плюс се изплълнява преди събирането.

## Присвояване

Нека да отбележим, че знака за присвояване `=` също е оператор. В таблицата за предимство е отбелязан с много нисък приоритет - `3`.

Ето защо, когато присвояваме стойност на променлива, като `x = 2 * 2 + 1`, изчисленията се изпълняват първи и след това `=` е изпълнен, запазвайки резулата в `x`.

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

Възможно е да се създаде верига от присвоявания:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Веригата от присвоявания се изпълнява от дясно на ляво. Първо, най-десният израз `2 + 2` е изпълнен и е присвоен от променливите отляво: `c`, `b` и `a`. Накрая, всички променливи споделят една стойност.

````smart header="Операторът за присвояване `\"=\"` връща стойност"
Един оператор винаги връща стойност. Това е очевидни за повечето такива, като събиране `+` или умножение `*`, но оператора за присвояване следва същото правило.

Изпълнението на `x = value` записва стойността `value` в променливата `x` *и я връща*.

Ето пример, в който присвояването е използвано в по-сложен израз:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

В примера по-горе, резултата от израза `(a = b + 1)` е стойността която е присвоена от `a` (която е `3`). След което е използвана за по-нататъшни изчисления.

Забавен код, нали? Трябва да разберем как работи, защото понякога го виждаме в JavaScript библиотеки, но не трябва да го пишем сами. Такива тричкета не правят кода по-четим и разбираем.
````

## Делене с остатък %

Операторът за делене с остатък `%`, въпреки символа които използва, не е свързан с проценти.

Резултатът `a % b` е остатъкът от целочисленото делене на `a` на `b`.

Например:

```js run
alert( 5 % 2 ); // 1 е остатъкът на 5 на 2
alert( 8 % 3 ); // 2 е остатъкът на 8 на 3
alert( 6 % 3 ); // 0 е остатъкът на 6 на 3
```

## Степенуване **

Операторът за степенуване `**` е скорошно допълнение към езика.

За естественото число `b`, резултата от `a ** b` е променливата `a` да се умножи сама по себе си `b` пъти.

Например:

```js run
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

Операторът работи и за нецелочислени числа.

Например:

```js run
alert( 4 ** (1/2) ); // 2 (степенуването по 1/2 е същото като корен квадратен, това е математика)
alert( 8 ** (1/3) ); // 2 (степенуването по 1/3 е същото като корен кубичен)
```

## Увеличаване/Намаляване

<!-- Can't use -- in title, because built-in parse turns it into – -->

Увеличаването или намаляването на число с едно е сред най-често срещаните цифрови операции.

Така че, за това има специални оператори:

- **Увеличаване** `++` увеличава стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter++;        // работи като counter = counter + 1, но е по-кратък
    alert( counter ); // 3
    ```
- **Намаляване** `--` намалява стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter--;        // работи като counter = counter - 1, но е по-кратък
    alert( counter ); // 1
    ```

```warn
Увеличаване/Намаляване може да се използва само в/у променливи. Ако се опитате да ги използвате в/у стойност `5++` ще получите грешка.
```

Операторите `++` и `--` могат да бъдат поставени както преди, така и след променливата.

- Когато операторът е поставен след променливата, той е в своята "постфикс форма": `counter++`.
- Когато операторът е поставен пред променливата, той е в своята "префикс форма": `++counter`.

И двете форми изпълняват едно и също действие: увеличават стойността на променливата `counter` с `1`.

А има ли някаква разлика тогава? Да, но можем да я видим само ако използваме стойността която `++/--` връщат.

Нека да поясним. Както знаем всички оператори връщат стойност. Операторите за Увеличаване/Намаляване не са изключение. Префикс формата връща новата стойност докато постфикс формата връща старата стойност (преди да увеличена/намалена).

За да видим разликата, нека да разгледаме няколко примера:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

На ред `(*)`, *префикс* формата `++counter` увеличава `counter` с едно и връща новата стойност `2`. И така, `alert` показва `2`.

Сега нека да разгледаме постфикс формата:

```js run
let counter = 1;
let a = counter++; // (*) променяме ++counter на counter++

alert(a); // *!*1*/!*
```

На ред `(*)`, *постфикс* формата `counter++` също увеличава `counter` с едно, но връща *старата* стойност (тази преди увеличението). И така, `alert` показва `1`.

Да обобщим:

- Ако резултата от увеличаване/намаляване не е използван, то няма значение коя форма ще използваме:

    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, двете форми правят едно и също
    ```
- АКо искаме да увеличим стойността на променлива *и* веднага да използваме резултата от операцията, то ние ще използваме префикс формата:

    ```js run
    let counter = 0;
    alert( ++counter ); // 1
    ```
- Ако искаме да увеличим стойността на променива, но да използваме старата й стойност, то ние ще използване постфикс формата:

    ```js run
    let counter = 0;
    alert( counter++ ); // 0
    ```

````smart header="Increment/decrement among other operators"
Операторите `++/--` мога да се използват и вътре в изрази. Тяхното предимство е по-високо от това на други математически оператори.

Например:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

Сравнено с:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, защото counter++ връща "старата" стойност
```

Въпреки, че технически това е добре, подобни изрази правят кода по-трудно четим. На една линия се изпълняват мого действия -- не е добре.

Докато чете, едно бързо "вертикално" поглеждане може много лесно да пропусне нещо като`counter++` и няма да разбере, че променливата се е увеличила.

Ние препоръчваме стила "една линия -- едно действие":

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## Побитови оператори

Побитовите оператори третират аргумемтоте като 32-битови цели числа и работят на нивото на тяхното бинарно представяне.

Тези оператори не са спесифични за JavaScript. Те се поддържат от повечето програмни езици.

Списък на операторите:

- И(AND) ( `&` )
- Или(OR) ( `|` )
- Изключващо или(XOR) ( `^` )
- Не(NOT) ( `~` )
- Отместване вляво ( `<<` )
- Отместване вдясно ( `>>` )
- Отместване вдясно и запълване с нули ( `>>>` )

Тези оператори се използват много рядко. За да ги разберем, трябва да се задълбочим в ниското ниво на представяне на числата и не би било оптимално да го направим в момента, още повече, че скоро няма да ни трябват. Ако сте любопитни, можете да прочетете статията [Побитови оператори](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) в MDN. По-практично би било да го направите, когато възникне реална нужда.

## Промяна на място

Често ни се налга да приложим оператор в/у променлива и да запазим резултата в същата такава.

Например:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

Този израз може да бъде съкратен, като използваме операторите `+=` и `*=`:

```js run
let n = 2;
n += 5; // now n = 7 (същото като n = n + 5)
n *= 2; // now n = 14 (същото като n = n * 2)

alert( n ); // 14
```

За всички аритметични и битови оператори съществуват кратки оператори "модифицирай и присвой": `/=`, `-=`, и т.н.

Тези оператори имат същото предимство като нормално зададените, така че те се изпълняват след повечето други изчисления:

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (дясната страна е изпълнена първа, също като n *= 8)
```

## Запетая

Операторът запетая `,` е един от най-рядко срещаните и използвани оператори. Понякога се използва за да се пише по-кратък код, за това трябва да го разгледаме, така че да знаем както се случва ако го видим.

Операторът запетая ни позволява да изпълним няколко израза, разделяйки ги със запетая `,`. Всеки от тях е изпълнен, но се връща резултата само на последния.

Например:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (резултата от 3 + 4)
```

Тък, първият израз `1 + 2` е изпълнен, а резултатът му е захвърлен. След това, `3 + 4` е изпълнен, а резултатът му е върнат.

```smart header="Запетаята има много ниско предимство"
Забележете че запетаята има много ниско предимсвто, по-ниско от `=`, затова скобите са от значение в примера по-горе.

Без тях: `a = 1 + 2, 3 + 4` изпълнява `+` първи, събирайки числата и получвайаки `a = 3, 7`, след това `=` просвоява `a = 3`, а останалата част е игнорирана. Все едно имаме израза `(a = 1 + 2), 3 + 4`.
```

Защо се нуждаем от оператор, който изхвърля всичко, освен последния израз?

Понякога хората го използват в по-сложни конструкции, за да поставят няколко действия в един ред.

Например:

```js
// три оператора на един ред
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

Такива трикове са използвани в множесто JavaScript рамки за приложения(frameworks). Затова ги споменаваме. Но обикновено те не подобряват четимостта на кода, така че трябва да помислим добре, преди да ги използваме.
