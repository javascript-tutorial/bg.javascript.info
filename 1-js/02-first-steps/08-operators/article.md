<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
# Оператори
=======
# Basic operators, maths
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

Познаваме много оператори още от училище. Те са знаците като събиране `+`, умножение `*`, изваждане `-` и т.н.

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
В тази глава ще се съсредоточим върху аспекти на операторите, които не са обхванати от училищната аритметика.
=======
In this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

## Термини: "едноаргументен", "двуаргументен", "операнд"

Преди да продължим, нека да разберем някои общи термини.

- *Операнд* -- е това, към което се прилагат операторите. Например, в умножението `5 * 2` има два операнда: левият операнд `5` и десният операнд `2`. Понякога хората ги наричат "аргументи" вместо "операнди".
- Един оператор е *едноаргументен* ако има само един операнд. Например, едноаргументен минус `-` обръща знака на числото:

    ```js run
    let x = 1;

    *!*
    x = -x;
    */!*
    alert( x ); // -1, приложен е едноаргументен минус
    ```
- Един оператор е *двуаргументен* ако има два операнда. Същият минус съществува и в двуаргументен вариянт:

    ```js run no-beautify
    let x = 1, y = 3;
    alert( y - x ); // 2, приложен е двуаргументен минус
    ```

    Формално в примерите по-горе имаме два различни оператора, които споделят един и същ символ: оператора за отрицание, едноаргументен оператор, който обръща знака на число, и оператора за изваждане, двуаргументен оператор, който изважда едно число от друго.

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
## Свързване на символни низове(текст), двуаргументен +

Сега, нека да разгледаме някои специални функции на JavaScript операторите, които са извън училищната аритметика.
=======
## Maths

The following math operations are supported:

- Addition `+`,
- Subtraction `-`,
- Multiplication `*`,
- Division `/`,
- Remainder `%`,
- Exponentiation `**`.

The first four are straightforward, while `%` and `**` need a few words about them.

### Remainder %

The remainder operator `%`, despite its appearance, is not related to percents.

The result of `a % b` is the [remainder](https://en.wikipedia.org/wiki/Remainder) of the integer division of `a` by `b`.

For instance:

```js run
alert( 5 % 2 ); // 1, a remainder of 5 divided by 2
alert( 8 % 3 ); // 2, a remainder of 8 divided by 3
```

### Exponentiation **

The exponentiation operator `a ** b` multiplies `a` by itself `b` times.

For instance:

```js run
alert( 2 ** 2 ); // 4  (2 multiplied by itself 2 times)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 times)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 times)
```

Mathematically, the exponentiation is defined for non-integer numbers as well. For example, a square root is an exponentiation by `1/2`:

```js run
alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
```


## String concatenation with binary +

Let's meet features of JavaScript operators that are beyond school arithmetics.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

Обикновено, оператора плюс `+` събира числа.

Но, ако двуаргоментниият плус `+` се използва със символни низове(текст), то ги слива(обединява):

```js
let s = "моят" + "текст";
alert(s); // моят текст
```

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Забележете, че ако един от аргументите е символен низ(текст), то и другият аргумент е преобразуван в такъв.
=======
Note that if any of the operands is a string, then the other one is converted to a string too.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

Например:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Забележете, няма значение дали първият аргумент е символен низ(текст) или вторият. Правилото е просто: ако един от аргументите е символен низ(текст), то и другият също е преобразуван в символен низ(текст).

Имайте предвид обаче, че операциите се изпълняват от ляво на дясно. Ако има две числа, последвани от символен низ(текст), числата ще бъдат събрани, преди да бъдат преобразувани в символен низ(текст):
=======
See, it doesn't matter whether the first operand is a string or the second one.

Here's a more complex example:
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

```js run
alert(2 + 2 + '1' ); // "41",а не "221"
```

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Свързване на символни низове(текст) и преобразуването в такива е особеност на двуаргоментния плюс `+`. Другите аритметични оператори работят само с числа и винаги преобразуват своите аргументи в такива.

Например, изваждане и делене:
=======
Here, operators work one after another. The first `+` sums two numbers, so it returns `4`, then the next `+` adds the string `1` to it, so it's like `4 + '1' = 41`.

The binary `+` is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.

Here's the demo for subtraction and division:
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

```js run
alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
```

## Преобразуване в число, едноаргументен +

Плюсът `+` има две форми: двуаргументна форма, която разгледахме по-горе, и едноаргументна форма.

Едноаргументният плус, или с други думи, операторът плус `+` приложен към един аргумент, не прави нищо, когато е приложен към число. Но ако аргумента не е число, едноаргументният плус преобразува този аргумент в такова.

Например:

```js run
// Няма ефект в/у числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// Преобразува в числови стойности
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

Всъщност, прави същото нещо като функцията `Number(...)`, но е по-кратък.

Необходимостта от преобразуването на символни низове(текст) в числа възниква много често. Например, когато получаваме стойности от полетата на форма в HTML, те обикновено са под формата на символен низ(текст). Ами ако искаме да ги съберем?

 Двуаргоментният плюс ще ги свърже в символен низ(текст):

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", Двуаргоментният плюс свързва символни низизове(текст)
```

Ако искаме да ги използваме като числа, ние трябва да ги преобразуваме в такива и след това да ги съберем:

```js run
let apples = "2";
let oranges = "3";

*!*
// и двете стойности са конвертиррани в числа, преди да използваме двуаргоментен плюс
alert( +apples + +oranges ); // 5
*/!*

// по-дългият вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

От математическа гледна точка, изобилието от плюсове може да изглежда странно. Но от гледна точка на програмист, няма нищо странно: едноаргументните плюсове са приложени първи, те преобразувант символните низове(текст) в числа, а след това двуаргументният плус ги събира.

А защо едноаргументните плюсове се прилагат към аргументите пред двуаргументният? Както ще видим, това е заради тяхното по-голямо  *предимство*.

## Предимство на операторите

Ако в един израз има повече от един оператор, реда на тяхното изпълнение се определя от тяхното *предимство*, или с други думи, приоритета на операторите по подразбиране.

Още от училище всички знаем, че умножението в израза `1 + 2 * 2` трябва да се изчисли преди събирането. Точно това означава предимството. Посочено е, че умножението има *по-голям приоритет* от събирането.

Скобите отменят всяко предимство, така че ако не сме доволни от подредбата по подразбиране, можем да ги използваме, за да я променим. Например, можем да напишем `(1 + 2) * 2`.

Има много оператори в JavaScript. Всеки оператор има съответен приоритет. Този с по-голям приоритет се изпълнява първи. Ако приоритетът е равен, изпълнението е от ляво на дясно.

Ето извадка от [таблицата за предимство](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence) (няма нужда да помните това, но имайте предвид, че едноаргументните оператори са с по-висок приоритет от съответните двуаргументни):

| Предимство | Име | Знак |
|------------|------|------|
| ... | ... | ... |
<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
| 16 | едноаргументен плюс | `+` |
| 16 | едноаргументен минус | `-` |
| 14 | умножение | `*` |
| 14 | делене | `/` |
| 13 | събиране | `+` |
| 13 | изваждане | `-` |
=======
| 17 | unary plus | `+` |
| 17 | unary negation | `-` |
| 16 | exponentiation | `**` |
| 15 | multiplication | `*` |
| 15 | division | `/` |
| 13 | addition | `+` |
| 13 | subtraction | `-` |
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md
| ... | ... | ... |
| 3 | присвояване | `=` |
| ... | ... | ... |

Както можем да видим, "едноаргументният плюс" има приоритет `16`, който е по-висок от `13`, този на "събиране" (двуаргументният плюс). Ето защо, в израза `"+apples + +oranges"`, едноаргументният плюс се изплълнява преди събирането.

## Присвояване

Нека да отбележим, че знака за присвояване `=` също е оператор. В таблицата за предимство е отбелязан с много нисък приоритет - `3`.

Ето защо, когато присвояваме стойност на променлива, като `x = 2 * 2 + 1`, изчисленията се изпълняват първи и след това `=` е изпълнен, запазвайки резулата в `x`.

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Възможно е да се създаде верига от присвоявания:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Веригата от присвоявания се изпълнява от дясно на ляво. Първо, най-десният израз `2 + 2` е изпълнен и е присвоен от променливите отляво: `c`, `b` и `a`. Накрая, всички променливи споделят една стойност.

````smart header="Операторът за присвояване `\"=\"` връща стойност"
Един оператор винаги връща стойност. Това е очевидни за повечето такива, като събиране `+` или умножение `*`, но оператора за присвояване следва същото правило.
=======
### Assignment = returns a value

The fact of `=` being an operator, not a "magical" language construct has an interesting implication.

Most operators in JavaScript return a value. That's obvious for `+` and `-`, but also true for `=`.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

Изпълнението на `x = value` записва стойността `value` в променливата `x` *и я връща*.

Ето пример, в който присвояването е използвано в по-сложен израз:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

В примера по-горе, резултата от израза `(a = b + 1)` е стойността която е присвоена от `a` (която е `3`). След което е използвана за по-нататъшни изчисления.

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Забавен код, нали? Трябва да разберем как работи, защото понякога го виждаме в JavaScript библиотеки, но не трябва да го пишем сами. Такива тричкета не правят кода по-четим и разбираем.
````

## Делене с остатък %

Операторът за делене с остатък `%`, въпреки символа които използва, не е свързан с проценти.

Резултатът `a % b` е остатъкът от целочисленото делене на `a` на `b`.

Например:

```js run
alert( 5 % 2 ); // 1 е остатъкът на 5 на 2
alert( 8 % 3 ); // 2 е остатъкът на 8 на 3
alert( 6 % 3 ); // 0 е остатъкът на 6 на 3
```

## Степенуване **

Операторът за степенуване `**` е скорошно допълнение към езика.

За естественото число `b`, резултата от `a ** b` е променливата `a` да се умножи сама по себе си `b` пъти.

Например:
=======
Funny code, isn't it? We should understand how it works, because sometimes we see it in JavaScript libraries.

Although, please don't write the code like that. Such tricks definitely don't make code clearer or readable.

### Chaining assignments

Another interesting feature is the ability to chain assignments:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Chained assignments evaluate from right to left. First, the rightmost expression `2 + 2` is evaluated and then assigned to the variables on the left: `c`, `b` and `a`. At the end, all the variables share a single value.

Once again, for the purposes of readability it's better to split such code into few lines:

```js
c = 2 + 2;
b = c;
a = c;
```
That's easier to read, especially when eye-scanning the code fast.

## Modify-in-place

We often need to apply an operator to a variable and store the new result in that same variable.

For example:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

This notation can be shortened using the operators `+=` and `*=`:
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

```js run
let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14
```

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Операторът работи и за нецелочислени числа.

Например:

```js run
alert( 4 ** (1/2) ); // 2 (степенуването по 1/2 е същото като корен квадратен, това е математика)
alert( 8 ** (1/3) ); // 2 (степенуването по 1/3 е същото като корен кубичен)
=======
Short "modify-and-assign" operators exist for all arithmetical and bitwise operators: `/=`, `-=`, etc.

Such operators have the same precedence as a normal assignment, so they run after most other calculations:

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (right part evaluated first, same as n *= 8)
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md
```

## Увеличаване/Намаляване

<!-- Can't use -- in title, because the built-in parser turns it into a 'long dash' – -->

Увеличаването или намаляването на число с едно е сред най-често срещаните цифрови операции.

Така че, за това има специални оператори:

- **Увеличаване** `++` увеличава стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter++;        // работи като counter = counter + 1, но е по-кратък
    alert( counter ); // 3
    ```
- **Намаляване** `--` намалява стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter--;        // работи като counter = counter - 1, но е по-кратък
    alert( counter ); // 1
    ```

```warn
Увеличаване/Намаляване може да се използва само в/у променливи. Ако се опитате да ги използвате в/у стойност `5++` ще получите грешка.
```

Операторите `++` и `--` могат да бъдат поставени както преди, така и след променливата.

- Когато операторът е поставен след променливата, той е в своята "постфикс форма": `counter++`.
- Когато операторът е поставен пред променливата, той е в своята "префикс форма": `++counter`.

И двете форми изпълняват едно и също действие: увеличават стойността на променливата `counter` с `1`.

А има ли някаква разлика тогава? Да, но можем да я видим само ако използваме стойността която `++/--` връщат.

Нека да поясним. Както знаем всички оператори връщат стойност. Операторите за Увеличаване/Намаляване не са изключение. Префикс формата връща новата стойност докато постфикс формата връща старата стойност (преди да увеличена/намалена).

За да видим разликата, нека да разгледаме няколко примера:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

На ред `(*)`, *префикс* формата `++counter` увеличава `counter` с едно и връща новата стойност `2`. И така, `alert` показва `2`.

Сега нека да разгледаме постфикс формата:

```js run
let counter = 1;
let a = counter++; // (*) променяме ++counter на counter++

alert(a); // *!*1*/!*
```

На ред `(*)`, *постфикс* формата `counter++` също увеличава `counter` с едно, но връща *старата* стойност (тази преди увеличението). И така, `alert` показва `1`.

Да обобщим:

- Ако резултата от увеличаване/намаляване не е използван, то няма значение коя форма ще използваме:

    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, двете форми правят едно и също
    ```
- АКо искаме да увеличим стойността на променлива *и* веднага да използваме резултата от операцията, то ние ще използваме префикс формата:

    ```js run
    let counter = 0;
    alert( ++counter ); // 1
    ```
- Ако искаме да увеличим стойността на променива, но да използваме старата й стойност, то ние ще използване постфикс формата:

    ```js run
    let counter = 0;
    alert( counter++ ); // 0
    ```

````smart header="Increment/decrement among other operators"
Операторите `++/--` мога да се използват и вътре в изрази. Тяхното предимство е по-високо от това на други математически оператори.

Например:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

Сравнено с:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, защото counter++ връща "старата" стойност
```

Въпреки, че технически това е добре, подобни изрази правят кода по-трудно четим. На една линия се изпълняват мого действия -- не е добре.

Докато чете, едно бързо "вертикално" поглеждане може много лесно да пропусне нещо като`counter++` и няма да разбере, че променливата се е увеличила.

Ние препоръчваме стила "една линия -- едно действие":

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## Побитови оператори

Побитовите оператори третират аргумемтоте като 32-битови цели числа и работят на нивото на тяхното бинарно представяне.

Тези оператори не са спесифични за JavaScript. Те се поддържат от повечето програмни езици.

Списък на операторите:

- И(AND) ( `&` )
- Или(OR) ( `|` )
- Изключващо или(XOR) ( `^` )
- Не(NOT) ( `~` )
- Отместване вляво ( `<<` )
- Отместване вдясно ( `>>` )
- Отместване вдясно и запълване с нули ( `>>>` )

<<<<<<< HEAD:1-js/02-first-steps/07-operators/article.md
Тези оператори се използват много рядко. За да ги разберем, трябва да се задълбочим в ниското ниво на представяне на числата и не би било оптимално да го направим в момента, още повече, че скоро няма да ни трябват. Ако сте любопитни, можете да прочетете статията [Побитови оператори](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) в MDN. По-практично би било да го направите, когато възникне реална нужда.

## Промяна на място

Често ни се налга да приложим оператор в/у променлива и да запазим резултата в същата такава.

Например:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

Този израз може да бъде съкратен, като използваме операторите `+=` и `*=`:

```js run
let n = 2;
n += 5; // now n = 7 (същото като n = n + 5)
n *= 2; // now n = 14 (същото като n = n * 2)

alert( n ); // 14
```

За всички аритметични и битови оператори съществуват кратки оператори "модифицирай и присвой": `/=`, `-=`, и т.н.

Тези оператори имат същото предимство като нормално зададените, така че те се изпълняват след повечето други изчисления:

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (дясната страна е изпълнена първа, също като n *= 8)
```
=======
These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won't need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the [Bitwise Operators](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) article on MDN when a need arises.
>>>>>>> cd2c7ce3c8f033e6f7861ed1b126552e41ba3e31:1-js/02-first-steps/08-operators/article.md

## Запетая

Операторът запетая `,` е един от най-рядко срещаните и използвани оператори. Понякога се използва за да се пише по-кратък код, за това трябва да го разгледаме, така че да знаем както се случва ако го видим.

Операторът запетая ни позволява да изпълним няколко израза, разделяйки ги със запетая `,`. Всеки от тях е изпълнен, но се връща резултата само на последния.

Например:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (резултата от 3 + 4)
```

Тък, първият израз `1 + 2` е изпълнен, а резултатът му е захвърлен. След това, `3 + 4` е изпълнен, а резултатът му е върнат.

```smart header="Запетаята има много ниско предимство"
Забележете че запетаята има много ниско предимсвто, по-ниско от `=`, затова скобите са от значение в примера по-горе.

Без тях: `a = 1 + 2, 3 + 4` изпълнява `+` първи, събирайки числата и получвайаки `a = 3, 7`, след това `=` просвоява `a = 3`, а останалата част е игнорирана. Все едно имаме израза `(a = 1 + 2), 3 + 4`.
```

Защо се нуждаем от оператор, който изхвърля всичко, освен последния израз?

Понякога хората го използват в по-сложни конструкции, за да поставят няколко действия в един ред.

Например:

```js
// три оператора на един ред
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

Такива трикове са използвани в множесто JavaScript рамки за приложения(frameworks). Затова ги споменаваме. Но обикновено те не подобряват четимостта на кода, така че трябва да помислим добре, преди да ги използваме.
