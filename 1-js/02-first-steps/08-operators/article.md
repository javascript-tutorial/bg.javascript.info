# Прости оператори, математика

Познаваме много оператори още от училище. Те са знаците като събиране `+`, умножение `*`, изваждане `-` и т.н.

В тази глава ще се съсредоточим върху аспекти на операторите, които не са обхванати от училищната аритметика.

## Термини: "едноаргументен", "двуаргументен", "операнд"

Преди да продължим, нека да разберем някои общи термини.

- *Операнд* -- е това, към което се прилагат операторите. Например, в умножението `5 * 2` има два операнда: левият операнд `5` и десният операнд `2`. Понякога хората ги наричат "аргументи" вместо "операнди".
- Един оператор е *едноаргументен* ако има само един операнд. Например, едноаргументен минус `-` обръща знака на числото:

    ```js run
    let x = 1;

    *!*
    x = -x;
    */!*
    alert( x ); // -1, приложен е едноаргументен минус
    ```
- Един оператор е *двуаргументен* ако има два операнда. Същият минус съществува и в двуаргументен вариянт:

    ```js run no-beautify
    let x = 1, y = 3;
    alert( y - x ); // 2, приложен е двуаргументен минус
    ```

    Формално в примерите по-горе имаме два различни оператора, които споделят един и същ символ: оператора за отрицание, едноаргументен оператор, който обръща знака на число, и оператора за изваждане, двуаргументен оператор, който изважда едно число от друго.

## Математика

Поддържат се следните математически операции:

- Събиране `+`,
- Изваждане `-`,
- Умножение `*`,
- Делене `/`,
- Целочисленото деление / Делене с остатък `%`,
- степенуване `**`.

Първите четири са прави, докато `%` и `**` се нуждаят от няколко думи за тях.

### Делене с остатък %

Остатъчният оператор `%`, въпреки външния си вид, не е свързан с проценти.

Резултатът от `a % b` е [остатък](https://en.wikipedia.org/wiki/Remainder) от целочисленото деление на `a` и `b`.

Например:

```js run
alert( 5 % 2 ); // 1, остатък от 5, разделен на 2
alert( 8 % 3 ); // 2, остатък от 8, разделен на 3
```

### Степенуване **

Операторът на степенуване `a ** b` умножава `a` на себе си `b` пъти.

В училищната математика това го пишем ето така: а<sup>b</sup>.

Например:

```js run
alert( 2 ** 2 ); // 4  (2 умножени по себе си 2 пъти)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 пъти)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 пъти)
```

Математически, експоненцията е дефинирана и за нецелочислени числа. Например, квадратен корен е експоненция от `1/2`:

```js run
alert( 4 ** (1/2) ); // 2 (степен на 1/2 е същата като квадратен корен)
alert( 8 ** (1/3) ); // 2 (степен на 1/3 е същата като квадратен корен)
```

## Свързване на символни низове(текст), двуаргументен +

Сега, нека да разгледаме някои специални функции на JavaScript операторите, които са извън училищната аритметика.

Обикновено, оператора плюс `+` събира числа.

Но, ако двуаргоментниият плус `+` се използва със символни низове(текст), то ги слива(обединява):

```js
let s = "моят" + "текст";
alert(s); // моят текст
```

Забележете, че ако един от аргументите е символен низ(текст), то и другият аргумент е преобразуван в такъв.

Например:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Забележете, няма значение дали първият аргумент е символен низ(текст) или вторият.

Ето един по-сложен пример:

```js run
alert(2 + 2 + '1'); // "41",а не "221"
```

Тук, операторите работят един след друг. Първо `+` сумира двете числа, което връща `4`, след това следващия `+` добавя (конкатенира) низа `1`, така че е като `4 + '1' = '41'`;

Бинарния оператор  `+` е единственият оператор, който поддържа низове по такъв начин. Други аритметични оператори работят само с числа и винаги преобразуват своите операнди в числа.

Ето демонстрацията с изваждане и деление:

```js run
alert( 6 - '2' ); // 4, превръща '2' към число
alert( '6' / '2' ); // 3, превръща двата операнда към числа
```

## Преобразуване в число, едноаргументен +

Плюсът `+` има две форми: двуаргументна форма, която разгледахме по-горе, и едноаргументна форма.

Едноаргументният плус, или с други думи, операторът плус `+` приложен към един аргумент, не прави нищо, когато е приложен към число. Но ако аргумента не е число, едноаргументният плус преобразува този аргумент в такова.

Например:

```js run
// Няма ефект в/у числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// Преобразува в числови стойности
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

Всъщност, прави същото нещо като функцията `Number(...)`, но е по-кратък.

Необходимостта от преобразуването на символни низове(текст) в числа възниква много често. Например, когато получаваме стойности от полетата на форма в HTML, те обикновено са под формата на символен низ(текст). Ами ако искаме да ги съберем?

 Двуаргоментният плюс ще ги свърже в символен низ(текст):

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", Двуаргоментният плюс свързва символни низизове(текст)
```

Ако искаме да ги използваме като числа, ние трябва да ги преобразуваме в такива и след това да ги съберем:

```js run
let apples = "2";
let oranges = "3";

*!*
// и двете стойности са конвертиррани в числа, преди да използваме двуаргоментен плюс
alert( +apples + +oranges ); // 5
*/!*

// по-дългият вариант
// alert( Number(apples) + Number(oranges) ); // 5
```

От математическа гледна точка, изобилието от плюсове може да изглежда странно. Но от гледна точка на програмист, няма нищо странно: едноаргументните плюсове са приложени първи, те преобразувант символните низове(текст) в числа, а след това двуаргументният плус ги събира.

А защо едноаргументните плюсове се прилагат към аргументите пред двуаргументният? Както ще видим, това е заради тяхното по-голямо  *предимство*.

## Предимство на операторите

Ако в един израз има повече от един оператор, реда на тяхното изпълнение се определя от тяхното *предимство*, или с други думи, приоритета на операторите по подразбиране.

Още от училище всички знаем, че умножението в израза `1 + 2 * 2` трябва да се изчисли преди събирането. Точно това означава предимството. Посочено е, че умножението има *по-голям приоритет* от събирането.

Скобите отменят всяко предимство, така че ако не сме доволни от подредбата по подразбиране, можем да ги използваме, за да я променим. Например, можем да напишем `(1 + 2) * 2`.

Има много оператори в JavaScript. Всеки оператор има съответен приоритет. Този с по-голям приоритет се изпълнява първи. Ако приоритетът е равен, изпълнението е от ляво на дясно.

Ето извадка от [таблицата за предимство](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence) (няма нужда да помните това, но имайте предвид, че едноаргументните оператори са с по-висок приоритет от съответните двуаргументни):

| Предимство | Име | Знак |
|------------|------|------|
| ... | ... | ... |
<<<<<<< HEAD
| 17 | едноаргументен плюс | `+` |
| 17 | едноаргументен минус | `-` |
| 16 | степенуване | `**` |
| 15 | умножение | `*` |
| 15 | делене | `/` |
| 13 | събиране | `+` |
| 13 | изваждане | `-` |
| ... | ... | ... |
| 3 | присвояване | `=` |
| ... | ... | ... |

Както можем да видим, "едноаргументният плюс" има приоритет `17`, който е по-висок от `13`, този на "събиране" (двуаргументният плюс). Ето защо, в израза `"+apples + +oranges"`, едноаргументният плюс се изплълнява преди събирането.
=======
| 15 | unary plus | `+` |
| 15 | unary negation | `-` |
| 14 | exponentiation | `**` |
| 13 | multiplication | `*` |
| 13 | division | `/` |
| 12 | addition | `+` |
| 12 | subtraction | `-` |
| ... | ... | ... |
| 2 | assignment | `=` |
| ... | ... | ... |

As we can see, the "unary plus" has a priority of `15` which is higher than the `12` of "addition" (binary plus). That's why, in the expression `"+apples + +oranges"`, unary pluses work before the addition.
>>>>>>> e2f9e5840737e00846bfd492192d8a3828820c60

## Присвояване

<<<<<<< HEAD
Нека да отбележим, че знака за присвояване `=` също е оператор. В таблицата за предимство е отбелязан с много нисък приоритет - `3`.
=======
Let's note that an assignment `=` is also an operator. It is listed in the precedence table with the very low priority of `2`.
>>>>>>> e2f9e5840737e00846bfd492192d8a3828820c60

Ето защо, когато присвояваме стойност на променлива, като `x = 2 * 2 + 1`, изчисленията се изпълняват първи и след това `=` е изпълнен, запазвайки резулата в `x`.

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

### Присвояване = връща стойността

Фактът  `=` да е оператор, а не a "магическа" езикова конструкция има интересно значение.

Повечето оператори в JavaScript връщат стойност. Това е очевидно за `+` и `-`, но също така е вярно за `=`.

Изпълнението на `x = value` записва стойността `value` в променливата `x` *и я връща*.

Ето пример, в който присвояването е използвано в по-сложен израз:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

В примера по-горе, резултата от израза `(a = b + 1)` е стойността която е присвоена от `a` (която е `3`). След което е използвана за по-нататъшни изчисления.

Смешен код, нали? Трябва да разберем как работи, защото понякога го виждаме в библиотеките на JavaScript.

Въпреки това, моля, не пишете кода така. Подобни трикове определено не правят кода по-ясен или четим.

### Верига от присвоявания

Възможно е да се създаде верига от присвоявания:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Веригата от присвоявания се изпълнява от дясно на ляво. Първо, най-десният израз `2 + 2` е изпълнен и е присвоен от променливите отляво: `c`, `b` и `a`. Накрая, всички променливи споделят една стойност.

Още веднъж, за целите на четимостта е по-добре да разделите такъв код на няколко реда:
```js
c = 2 + 2;
b = c;
a = c;
```
Това е по-лесно за четене, особено при бързо сканиране на кода.

## Промяна на място

Често се налага да прилагаме оператор към променлива и да съхраняваме новия резултат в същата променлива.

Например:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

Тази нотация може да бъде съкратена с помощта на операторите `=` и `* =`:

```js run
let n = 2;
n += 5; // сега n = 7 (същото като n = n + 5)
n *= 2; // сега n = 14 (същото като n = n * 2)

alert( n ); // 14
```

За всички аритметични и битови оператори съществуват кратки оператори, които "модифицират и задават" стойността: `/ =`, `- =` и т.н.

Такива оператори имат същото предимство като нормалното присвояване, така че те се изпълняват след повечето други изчисления:

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (дясната част се изчислява първо, същото като n *= 8)
```

## Увеличаване/Намаляване

<!-- Не може да се използва -- в заглавиет, защото tв вграден парсер го превръща в 'дълъг тире' – -->

Увеличаването или намаляването на число с едно е сред най-често срещаните цифрови операции.

Така че, за това има специални оператори:

- **Увеличаване** `++` увеличава стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter++;        // работи като counter = counter + 1, но е по-кратък
    alert( counter ); // 3
    ```
- **Намаляване** `--` намалява стойността на променливата с 1:

    ```js run no-beautify
    let counter = 2;
    counter--;        // работи като counter = counter - 1, но е по-кратък
    alert( counter ); // 1
    ```

```warn header="Важно"
Увеличаване/Намаляване може да се използва само в/у променливи. Ако се опитате да ги използвате в/у стойност `5++` ще получите грешка.
```

Операторите `++` и `--` могат да бъдат поставени както преди, така и след променливата.

- Когато операторът е поставен след променливата, той е в своята "постфикс форма": `counter++`.
- Когато операторът е поставен пред променливата, той е в своята "префикс форма": `++counter`.

И двете форми изпълняват едно и също действие: увеличават стойността на променливата `counter` с `1`.

А има ли някаква разлика тогава? Да, но можем да я видим само ако използваме стойността която `++/--` връщат.

Нека да поясним. Както знаем всички оператори връщат стойност. Операторите за Увеличаване/Намаляване не са изключение. Префикс формата връща новата стойност докато постфикс формата връща старата стойност (преди да увеличена/намалена).

За да видим разликата, нека да разгледаме няколко примера:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

На ред `(*)`, *префикс* формата `++counter` увеличава `counter` с едно и връща новата стойност `2`. И така, `alert` показва `2`.

Сега нека да разгледаме постфикс формата:

```js run
let counter = 1;
let a = counter++; // (*) променяме ++counter на counter++

alert(a); // *!*1*/!*
```

На ред `(*)`, *постфикс* формата `counter++` също увеличава `counter` с едно, но връща *старата* стойност (тази преди увеличението). И така, `alert` показва `1`.

Да обобщим:

- Ако резултата от увеличаване/намаляване не е използван, то няма значение коя форма ще използваме:

    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, двете форми правят едно и също
    ```
- АКо искаме да увеличим стойността на променлива *и* веднага да използваме резултата от операцията, то ние ще използваме префикс формата:

    ```js run
    let counter = 0;
    alert( ++counter ); // 1
    ```
- Ако искаме да увеличим стойността на променива, но да използваме старата й стойност, то ние ще използване постфикс формата:

    ```js run
    let counter = 0;
    alert( counter++ ); // 0
    ```

````smart header="Увеличаване / намаляване сред другите оператори"
Операторите `++/--` мога да се използват и вътре в изрази. Тяхното предимство е по-високо от това на други математически оператори.

Например:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

Сравнено с:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, защото counter++ връща "старата" стойност
```

Въпреки, че технически това е добре, подобни изрази правят кода по-трудно четим. На една линия се изпълняват мого действия -- не е добре.

Докато четете, при едно бързо "вертикално" поглеждане можете много лесно да пропусне нещо като`counter++` и няма да разбере, че променливата се е увеличила.

Ние препоръчваме стила "една линия -- едно действие":

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## Побитови оператори

Побитовите оператори третират аргумемтоте като 32-битови цели числа и работят на нивото на тяхното бинарно представяне.

Тези оператори не са спесифични за JavaScript. Те се поддържат от повечето програмни езици.

Списък на операторите:

- И(AND) ( `&` )
- Или(OR) ( `|` )
- Изключващо или(XOR) ( `^` )
- Не(NOT) ( `~` )
- Отместване вляво ( `<<` )
- Отместване вдясно ( `>>` )
- Отместване вдясно и запълване с нули ( `>>>` )

<<<<<<< HEAD
Тези оператори се използват много рядко. За да ги разберем, трябва да се задълбочим в ниското ниво на представяне на числата и не би било оптимално да го направим в момента, още повече, че скоро няма да ни трябват. Ако сте любопитни, можете да прочетете статията [Побитови оператори](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Bitwise) в MDN. По-практично би било да го направите, когато възникне реална нужда.
=======
These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won't need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the [Bitwise Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators) chapter on MDN when a need arises.
>>>>>>> 30a5d5e2a7c3504c9afd5028f83f4a696e60aede

## Запетая

Операторът запетая `,` е един от най-рядко срещаните и използвани оператори. Понякога се използва за да се пише по-кратък код, за това трябва да го разгледаме, така че да знаем както се случва ако го видим.

Операторът запетая ни позволява да изпълним няколко израза, разделяйки ги със запетая `,`. Всеки от тях е изпълнен, но се връща резултата само на последния.

Например:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (резултата от 3 + 4)
```

Тък, първият израз `1 + 2` е изпълнен, а резултатът му е захвърлен. След това, `3 + 4` е изпълнен, а резултатът му е върнат.

```smart header="Запетаята има много ниско предимство"
Забележете че запетаята има много ниско предимсвто, по-ниско от `=`, затова скобите са от значение в примера по-горе.

Без тях: `a = 1 + 2, 3 + 4` изпълнява `+` първи, събирайки числата и получвайаки `a = 3, 7`, след това `=` просвоява `a = 3`, а останалата част е игнорирана. Все едно имаме израза `(a = 1 + 2), 3 + 4`.
```

Защо се нуждаем от оператор, който изхвърля всичко, освен последния израз?

Понякога хората го използват в по-сложни конструкции, за да поставят няколко действия в един ред.

Например:

```js
// три оператора на един ред
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

Такива трикове са използвани в множесто JavaScript рамки за приложения(frameworks). Затова ги споменаваме. Но обикновено те не подобряват четимостта на кода, така че трябва да помислим добре, преди да ги използваме.
