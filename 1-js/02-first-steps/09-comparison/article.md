# Оператори за сравнения

Ние познаваме много оператори за сравнение от математика:

В JavaScript те се напишат така:

- По-голямо/По-малко: <code>a &gt; b</code>, <code>a &lt; b</code>.
- По-голямо/По-мaлко или равно: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Равно: `a == b` (моля, обърнете внимание на знака с двойно равно `=`.Единичният знак `a = b` означава присвояване).
- Неравенство. В математиката се изписва като <code>&ne;</code>, но в JavaScript се записва със знака за присвояване с удивителна пред него: <code>a != b</code>.

В тази статия ще научим повече за различните видове сравнения, как ги прави JavaScript, включително важни особености.

В края ще намерите добра рецепта, за да избегнете проблеми, свързани с JavaScript.

## Резултатът е от булев тип

Всички оператори за сравнение връщат булева стойност:

- `true` -- означава "да", "правилно" или "истина".
- `false` -- означава "не", "грешно" или "лъжа".

Например:

```js run
alert( 2 > 1 );  // true (правилно)
alert( 2 == 1 ); // false (грешно)
alert( 2 != 1 ); // true (истина)
```

Резултатът от сравнение може да бъде присвоен на променлива, както всяка друга стойност:

```js run
let result = 5 > 4; // присвояване на резултата от сравнението
alert( result ); // вярно
```

## Сравняване на символни низове(текст)

За да се види дали един символен низ(текс) е по-голям от друг, JavaScript използва така нареченият "речник" или "лексикографски" ред.

С други думи, символите низове се сравняват символ по символ.

Например:

```js run
alert( 'Z' > 'A' ); // вярно
alert( 'Glow' > 'Glee' ); // вярно
alert( 'Bee' > 'Be' ); // вярно
```

Алгоритъмът за сравняване на символни низове(текст) е прост:

1. Сравнява първият символ на двата низа.
2. Ако първият символ от първият ние е по-голям(или по-малък) от този на втория низ, то първият ние по-голям(или по-малък) от вторият. Готово.
3. Иначе, ако двата първи символа и на двата низа са равни, сравнява вторите символи по същия начин.
4. Повтаря докато не стигне края на един от двата низа.
5. Ако и двата низа имат еднаква дължина, то те са равни. Иначе, по-дългият низ е по-голям.

В горните примери сравнението `'Z' > 'A'` стига до резултат на първата стъпка, докато низовете `"Glow"` и `"Glee"`
се сравняват по символ по символ:

1. `G` е същото като `G`.
2. `l` е същото като `l`.
3. `o` е по-голямо от `e`. Спира тук. Първият низ е по-голям.

```smart header="Не истински речник, а по реда на Unicode"
Алгоритъмът за сравнение, даден по-горе, е приблизително еквивалентен на този, използван в речниците или телефонните указатели, но не е абсолютно същия.

Например, дали е главна или малка буква е значение. Главна буква `"A"` не е равна на малката буква `"a"`. Кое е по-голямо? Малката буква `"a"`. Защо? Тъй като малкият символ има по-голям индекс във вътрешната таблица за кодиране, която JavaScript използва (Unicode). 
Ще се върнем към конкретни подробности и последиците от това в главата <info:string>.
```

## Сравняване на различни типове

Когато сравняваме стойности от различен тип, JavaScript преобразува стойностите в число.

Например:

```js run
alert( '2' > 1 ); // вярно, символа '2' се преобразува в числото 2
alert( '01' == 1 ); // вярно, символният низ '01' се преобразува в числото 1
```

За стойности от булев тип, `true` се преобразува в `1` и `false` се преобразува в `0`.

например:

```js run
alert( true == 1 ); // вярно
alert( false == 0 ); // вярно
```

````smart header="Забавно последствие"
Възможно е в същото време:

- Две стойности са равни.
- Едната е `true` като булев тип, а другата да е `false` като булев тип.

Например:

```js run
let a = 0;
alert( Boolean(a) ); // грешно

let b = "0";
alert( Boolean(b) ); // вярно

alert(a == b); // вярно!
```

От гледна точка на JavaScript, този резултат е доста нормален. Проверка за равенство преобразува стойности, използвайки числовото преобразуване(т.е. `"0"` се преобразува в `0`), докато изричното `Boolean` преобразуване използва други правила.
````

## Строго равенство

При нормалната проверка за равенство `==` има проблем. Тя не различава `0` от `false`:

```js run
alert( 0 == false ); // вярно
```

Същото нещо се получава и при празен символен низ:

```js run
alert( '' == false ); // вярно
```

Това се случва, защото операндите от различни типове се преобразуват в числа от оператора на равенството `==`. Празният символен низ, точно като `false`, се преобразува в нула.

Какво да правим, ако искаме да се разграничим `0` от `false`?

**Операторът за строго равенство `===` проверява равенството без преобразуване на типа.**

С други думи, Ако `a` и `b` са от различен тип, тогава `a === b` веднага връща `false` без да прави опит да преобразува типовете.

Нека да опитаме:

```js run
alert( 0 === false ); // грешно, bзащото са от различен тип
```

Също така има и оператор за "строго неравенство" - `!==`, като аналог на `!=`.

Операторът за строго равенство е малко по-дълъг за писане, но прави очевидно какво се случва и оставя по-малко място за грешки.

## Сравняване с null и undefined

Има неинтуитивно поведение, когато `null` или `undefined` са срявнявани с други стойности.

За строга проверка за равенство `===`
: Тези стойности са различни, защото всяка от тях е различен тип.

    ```js run
    alert( null === undefined ); // грешно
    ```

За не строга проверка `==`
: Има специално правило. Тези двете са "сладка двойка": те са равни една на друга (в смисъла на `==`), но не и на друга стойност.

    ```js run
    alert( null == undefined ); // вярно
    ```

За математически и други сравнения `< > <= >=`
: `null/undefined` се преобразуват в числа: `null` става `0`, докато `undefined` става `NaN`.

Сега нека видим някои смешни неща, които се случват, когато прилагаме тези правила. И, което е по-важно, как да не попаднете в капан с тях.

### Странен резултат: null vs 0

Нека да сравним `null` с нула:

```js run
alert( null > 0 );  // (1) грешно
alert( null == 0 ); // (2) грешно
alert( null >= 0 ); // (3) *!*правилно*/!*
```

Математически погледнато, това е странно. Последният резултат твърди, че "`null` е по-голямо или равно на нула", следователно в едно от по-горните твърдения резултатът трябва да е `true`, но и двата са отрицателни.

Причината е там, че проверката за равенство `==` и тази за сравнение `> < >= <=` работят разлочо. При проверка за равенство `null` се преобразува в число, третирайки я като `0`. Ето защо (3) `null >= 0` е вярно, а (1) `null > 0` е грешно.

От друга страна, проверката за равенство `==` за `undefined` и `null` се дефинира така, че, без да се преобразува, те са равни един на друг и на никой друг. Ето защо (2) `null == 0` е грешно.

### Несравнимо undefined

Стойността `undefined` не трябва да се сравнява с други стойности:

```js run
alert( undefined > 0 ); // грешно (1)
alert( undefined < 0 ); // грешно (2)
alert( undefined == 0 ); // грешно (3)
```

Защо не харесва нулата? Винаги е грешно!

Получихме този резултат, защото:

- Сравнения `(1)` и `(2)` връщат `грешно`, защото `undefined` се преобразува в `NaN` и `NaN`е специален числов тип, който връща `false` за всички сравнения.
- Проверката за равенство `(3)` връща `грешно`, защото `undefined` е равно само на `null`, `undefined`, и на никоя друга стойност.

### Избягвайте проблемите

Защо прегледахме тези примери? Трябва ли да помним тези особености през цялото време? Е, всъщност не. Всъщност тези сложни неща постепенно ще станат познати с течение на времето, но има солиден начин да избягвате проблемите с тях:

- Tретирайте всяко сравнение с `undefined/null`, с изключение на строгото равенство `===`, с огромно внимание.
- Не използвайте сравненията `>= > < <=` със стойност, която може да е `null/undefined`, освен ако наистина не сте сигурни в това, което правите. Ако променлива може да има тези стойности, проверете ги отделно.

## Обобщение

- Операторите за сравнение връщат булева стойност.
- Символните низове(текст) се сравняват символ по символ в "лексикографски" ред.
- Когато се сравняват стойности от различни типове, те се преобразуват в числа (с изключение на строга проверка за равенство).
- Стойностите `null` и `undefined` са равни `==` само една на друга, и на никоя друга стойност.
- Бъдете внимателни, когато използвате сравнения като `>` или `<` с променливи, които понякога могат да бъдат `null/undefined`. Проверката за `null/undefined` отделно е добра идея.
