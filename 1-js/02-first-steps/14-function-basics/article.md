# Функции

Често ни се налага да извършваме сходни действия на много места в нашия код.

Например, искаме да покажем добре изглеждащо съобщение, когато визитор се логне, излезе или може би някъде другаде.
Функциите са главните "строителни блокове" на програмата. Те позволяват кода да бъде изпълнен много пъти без повторение.

Вече видяхме примери за вградени функции като `alert(message)`, `prompt(message, default)` и `confirm(question)`. Но ние също можем да създаваме функции.

## Декларация на функция

За да създадем функция използваме _декларация на функция_.

Изглежда така:

```js
function showMessage() {
  alert("Здравейте всички!");
}
```

Ключовата дума `function` е първа, следвана от името _на функцията_, след това лист от _параметри_ между скобите (разделени от запетаи, празно в примера по-горе) и най-накрая кода на функцията, познат още като "тяло на функцията", между "{}" скобите.

```js
function name(parameters) {
  ...body...
}
```

Нашата нова функция може да бъде извикана по име: `showMessage()`.

Например:

```js run
function showMessage() {
  alert( 'Здравейте всички' );
}

*!*
showMessage();
showMessage();
*/!*
```

Името на функцията `showMessage()` изпълнява кода. Тук ще видим съобщението два пъти.

Примерът ясно демонстрира една от главните цели на функцията: да избегнем дупликации на кода.

Ако някога трябва да сменим съобщението или начина по който се показва, достатъчно е да сменим кода на едно място: функцията, която го изпълнява.

## Локални вариации

Вариация декларирана във функцияата е видима единствено вътре във функцията.

Като например:

```js run
function showMessage() {
*!*
  let message = "Здравей, аз съм JavaScript!"; // локална вариация
*/!*

  alert( message );
}

showMessage(); // Здравей, аз съм JavaScript!

alert( message ); // <-- Грешка! Вариацията е локална във функцията
```

## Външни вариации

Функцията също може да има достъп до външна вариация, като например:

```js run no-beautify
let *!*userName*/!* = 'Джон';

function showMessage() {
  let message = 'Здравей, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Здравей, Джон
```

Функцията има пълен достъп до външната вариация. Също така може да я модифицира.

Като например:

```js run
let *!*userName*/!* = 'Джон';

function showMessage() {
  *!*userName*/!* = "Боб"; // (1) промени външната вариация

  let message = 'Здравей, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*Джон*/!* преди изпълнението на функцията

showMessage();

alert( userName ); // *!*Боб*/!*, стойността беше модифицирана от функцията
```

Външната вариация се изпълнява само, ако няма локална такава.

Ако вариация със същото име е декларирана във функцията, то тогава _засенчва_ външната. Като например, в кода по-долу функцията използва локалната `userName`. Външната е игнорирана:

```js run
let userName = 'Джон';

function showMessage() {
*!*
  let userName = "Боб"; // декларира локална вариация
*/!*

  let message = 'Hello, ' + userName; // *!*Боб*/!*
  alert(message);
}

// Функцията ще създаде и използва своя собствена userName
showMessage();

alert( userName ); // *!*Джон*/!*, непроменена, функцията нямаше достъп до външната вариация
```

```smart header="Глобални вариации"
Вариации декларирани извън функции, като външната `userName` в кода по-горе, се наричат *глобални*.

Глобалните вариации са видими от всички функции (ако не са засенчени от локалните вариации).

Добра практика е да се миниманизира използването на глобални вариации. Модерният код има малко на брой глобални вариации или те въобще отсъстват. Повечето вариации са декларирани в свои собствени функции. Понякога обаче, те могат да са полезни да сухраняват проекционни данни.
```

## Параметри

Мовжем да задаваме своеобразна дата на функции изполвайки параметри (наричани също _функционални аргументи_) .

В примера по-долу, фукнцията има два параметъра: `from` и `text`.

```js run
function showMessage(*!*from, text*/!*) { // аргументи: from, text
  alert(from + ': ' + text);
}

*!*
showMessage('Ани', 'Здравей!'); // Ани: Здравей! (*)
showMessage('Ани', "Как е?"); // Ани: Как е? (**)
*/!*
```

Когато функцията е изпълнена в редовете `(*)` и `(**)`, дадените стойности са копирани в локалните вариации `from` и `text`. Функцията ги използва.

Ето още един пример: имаме вариация `from` и я предаваме на функцията. Забележи: функцията променя `from`, но промяната не е видима извън нея, защото функцията винаги получава копие от стойността:

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // прави "from" да изглежда по-добре
*/!*

  alert( from + ': ' + text );
}

let from = "Ани";

showMessage(from, "Здравей"); // *Ани*: Здравей

// стойността на "from" е същата, функцията модифицира локалното копие
alert( from ); // Ани
```

## Стойности по подразбиране

Ако не е предоставен параметър, то тогава неговата стойност става `undefined`.

Като например, познатата ни вече функция `showMessage(from, text)` може да бъде извикана с един единствен аргумент:

```js
showMessage("Анн");
```

Това не е грешка. Подобно изпълнение ще покаже `"Анн: undefined"`. Няма `text`, затова се предполага че `text === undefined`.

Ако искаме да използваме `text` по подразбиране в този случай, то тогава можем да го посочим след `=`:

```js run
function showMessage(from, *!*text = "не е зададен текст"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ann"); // Анн: не е зададен текст
```

Сега ако параметърът на `text` не е зададен, ще получи стойността `"не е зададен текст"`

Тук `"не е зададен текст"` е стринг, но може да бъде по-сложен израз, който е единствено изчислен и възложен ако параматърът. Така че, това също е възможно:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() изпълнява се само, ако не е зададен текст
  // резултатът му става стойността на text
}
```

```smart header="Оценяване на параметрите по подразбиране"
При JavaScript, параметър по подразбиране се оценява всеки път, когато функцията е извикана без ресяективния параметър.

В примера по-горе, `anotherFunction()` се извиква всеки път, когато `showMessage()` е извикана без `text` параметър.
```

````smart header="Старомодни параметри по подразбиране"
Старите версии на JavaScript не поддържат параметри по подразбиране. Така че има алтернативен начин да се поддържат, които могат да бъдат намерени главно в стари кодове.

Например, изрична проверка на `undefined`:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'не е зададен';
  }
*/!*

  alert( from + ": " + text );
}
```

...Или `||` оператора:

```js
function showMessage(from, text) {
  // ако текста е неверен получава "default" стойност
  text = text || 'не е зададен';
  ...
}
```


````

## Връщане на стойност

Функция може да върне стойност в кода на извикване като резултат.

Най-простия пример би бил функция, която събира две стойности:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Директивата `return` може да бъде на всяко място във функцията. Когато функцията я достигне, функцията спира и стойността се връща в кода на повикване (зададена на `result` по-горе).

Възможно е да има много повторения на `return` в една единствена функция. Например:

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('Имаш ли разрешение от родителите?');
*/!*
  }
}

let age = prompt('На колко години си?', 18);

if ( checkAge(age) ) {
  alert( 'Получен достъп' );
} else {
  alert( 'Отказан достъп' );
}
```

Възможно е да използваме `return` без стойност. Това кара да излезем от функцията веднага.

Например:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "Показва ти филма" ); // (*)
  // ...
}
```

В кода по-горе, ако `checkAge(age)` върне `false`, тогава `showMovie` няма да продължи към `alert`.

``smart header="Функция с празен `return` или с липсващ такъв връща `undefined`"
Ако функция не върне стойност, е същото ако върне `undefined`:

```js run
function doNothing() {
  /* празно */
}

alert(doNothing() === undefined); // true
```

Празен `return` е също като `return undefined`:

```js run
function doNothing() {
  return;
}

alert(doNothing() === undefined); // true
```

`````

````warn header="Никога не слагай нов ред между `return` и стойността"
При дълъг израз в `return`, може да е изкушаващо да го разделим на отделен ред, ето така:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
Това не работи, защото JavaScript предполага точка и запетая ";" след `return`. Това работи също като:

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

Което автоматично се превръща в празен "return".

Ако искаме да върнем израз в няколко реда, трябва да го започнем в същия ред като `return`. Или поне да сложим отварящата скоба на същия ред:

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
И ще работи точно както очакваме.
`````

## Именуване на функция [#function-naming]

Функциите са действия. Така че техните имена са обикновенно глаголи. Трябва да са кратки, възможно най-акуратни и описващи какво прави функцията, така че някой четящ кода получава индикация за дейността на функцията.

Общоприета практика е да започнем функция с глаголен префикс който описва действието. Трябва да има съгласие в екипа в това какво означават префиксите.
Например, функции които започват с `"show"` обикновенно показват нещо.

Функции започващи с...

- `"get…"` -- връщат стойност,
- `"calc…"` -- изчисляват нещо,
- `"create…"` -- създават нещо,
- `"check…"` -- проверяват нещо и връщат булева, и т.н.

Примери за такива имена:

```js no-beautify
showMessage(..)     // показва съобщение
getAge(..)          // връща годините (получава ги някакси)
calcSum(..)         // калкулира сбора и връща резултата
createForm(..)      // създава форма (и обикновенно я връща)
checkPermission(..) // проверява достъп, връща true/false
```

С префикси, един поглед на името на функцията дава да се разбере каква работа извършва и какъв тип стойност връща.

```smart header="Една функция -- едно действие"
Функция трябва да прави точно това, което показва името, не повече.

Две различни действия обикновенно заслужават две функции, дори когато те нормално са извиквани заедно (в този случай можем да създадем трета функция, която извиква двете).

Няколко примера на нарушаване на правилото:

- `getAge` -- ще бъде лошо, ако покаже `alert` с годините (трябва само да ги получи).
- `createForm` -- ще е лошо, ако модифицира документа, добавяйки форма (трябва само да я създаде и върне).
- `checkPermission` -- ще е лошо, ако покаже `access granted/denied` съобщение (трябва само да извърши проверката и върне резултата).

Тези примери очакват често срещани значения на префиксите. Ти и твоя екип сте свободни да се съгласите на значение, но нормални те не са много различни. Във всеки случай, трябва да имаш общо разбиране на това какво означават префиксите, какво префиксите на функциите могат и не могат да правят. Всички функции с общи префикси трябва да спазват правилата. И екипът трябва да се съгласува.
```

```smart header="Ултра-кратки имена на функции"
Функции, които се изпълняват много често понякога имат ултра-кратки имена.

Например, [jQuery](http://jquery.com) структурата дефинира функция с `$`. [Lodash](http://lodash.com/) библиотеката име своя собствена вътрешна функция с име `_`.

Има изключения. Като цяло името на функцията трябва да е сбито и описателно.
```

## Функции == Коментари

Функциите трябва да са кратки и да правят само едно нещо. Ако това нещо е голямо, може би си заслужава да разделим функцията на няколко по-кратки. Понякога следването на това правило може да не е лесно, но определено е нещо хубаво.

Отделна функция е не само по-лесно да бъде тествана и отстранени грешките -- самото и съществуване е страхотен коментар!

Например, сравни двете функции `showPrimes(n)` по-долу. Всяка произвежда [prime numbers](https://en.wikipedia.org/wiki/Prime_number) до `n`.

Първият вариант използва етикет:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i); // a prime
  }
}
```

Вторият вариант използва допълнителна функция `isPrime(n)` да тества за основа:

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

Вторият вариан е по-лесен за разбиране, нали? Вместо част от кода ние виждаме име на действието (`isPrime`). Понякога хората наричат такъв код _self-describing_ (самоописващ).

Така че функциите могат да бъдат създадени, дори когато не възнамеряваме да ги използваме отново. Те структурират кода и го правят по-лесен за четене.

## Обобщение

Декларация на функция изглежда така:

```js
function name(parameters, delimited, by, comma) {
  /* код */
}
```

- Стойности зададени на функция като параметри се копират в нейните локални вариации.
- Функция може да има достъп до други външни вариации. Но работи само отвътре навън. Кодът извън функцията не вижда нейните локални вариации.
- Функция може да върне стойност. Ако не го направи, тогава резултатът е `undefined`.

За да направим кога чист и лесен за разбиране, препоръчително е да използаме главно локални вариации и параметри във функцията, не външни вариации.

Винаги е по-лесно да разберем функция, която получава параметри, разботи с тях и връща резултат от функция, която не получава параметри, но модифицира външни вариации, като страничен ефект.

Именуване на функциите:

- Името трябва да описва ясно какво прави функцията. Когато видим извикване на функция в кода, добро име веднага ни дава да разберем какво прави и какво връща.
- Функцията е действие, така че имената на функциите са обикновено глаголи.
- Съществуват много добре известни префикси на функции като `create…`, `show…`, `get…`, `check…` и т.н. Използвай ги, за да подскажеш какво прави функцията.

Функциите да главните строителни болкове на скрипта. Сега ние се запознаваме с основното, така че да можем да започнем да ги създаваме и използваме. Но това е само началото на пътя. Ние ще се връщаме към тях много пъти, като се задълбочаваме в тяхните разширени функции.
