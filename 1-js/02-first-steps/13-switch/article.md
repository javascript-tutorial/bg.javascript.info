# Конструкцията "switch"

`switch` конструкция може да замести мновество `if` проверки.

Дава възможност за по-подробен начин да се сравни стойност с множество променливи.

## Синтаксис

Конструкцията `switch` има един или повече `case` блокове и един незадължителен default.

Изглежда така:

```js no-beautify
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- Стойността на `x` е проверена за стриктно равенство със стойността на първия `case` (това е, `value1`) след това на втория (`value2`) и така нататък.
- Ако е открито равенство, `switch` започва да изпълнява кода започвайки от съответния `case`, до най-близкия `break` (или до края на `switch` конструкцията).
- Ако нито един `case` не съвпада тогава `default` кода се изпълнява (ако съществува).

## Пример

Пример за `switch` (изпълнения код е подчертан):

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Твърде малко' );
    break;
*!*
  case 4:
    alert( 'Точно!' );
    break;
*/!*
  case 5:
    alert( 'Твърде много' );
    break;
  default:
    alert( "Не знам подобна стойност" );
}
```

Тук `switch` започва да сравнява `a` от първия `case` променлива, която е `3`. Няма съвпадение.

След това `4`. Което съвпада и затова изпълнението започва от `case 4` до следващия `break`.

**Ако няма `break` тогава изпълнението продължава със следващия `case` без никакви проверки.**

Пример без `break`:

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Твърде малко' );
*!*
  case 4:
    alert( 'Точно!' );
  case 5:
    alert( 'Твърде много' );
  default:
    alert( "Не знам подобна стойност" );
*/!*
}
```

В примера по-горе ще видим последователно изпълнение на три `alert` метода:

```js
alert( 'Точно!' );
alert( 'Твърде малко' );
alert( "Не знам подобна стойност" );
```

````smart header="Всеки израз може да бъде `switch/case` аргумент"
И `switch` и `case` позволяват своеволни изрази.

Пример:

```js run
let a = "1";
let b = 0;

switch (+a) {
*!*
  case b + 1:
    alert("Това се изпълнява, защото +a е 1, което е точно равно на b+1");
    break;
*/!*

  default:
    alert("това не се изпълнява");
}
```
Тук `+a` дава `1`, това е сравнено с `b + 1` в `case`, и кореспондиращия код се изпълнява.
````

## Групиране на "case"

Няколко варианта на `case` които споделят същия код могат да се групират.

Като например, ако искаме същия код да се изпълни за `case 3` и `case 5`:

```js run no-beautify
let a = 2 + 2;

switch (a) {
  case 4:
    alert('Точно!');
    break;

*!*
  case 3: // (*) групирани 2 случая
  case 5:
    alert('Грешно!');
    alert("Защо не си учил математика в училище?");
    break;
*/!*

  default:
    alert('Резултатът е странен. Наистина.');
}
```

Сега `3` и `5` показват същото съобщение.

Възможността да "групираме" случаи е страничен ефект от това как `switch/case` работи без `break`. Тук изпълнението на `case 3` започва от ред `(*)` и продължава през `case 5`, защото няма `break`.

## Начина на писане има значение

Нека подчертаем, че проверката за равенство е винаги стриктна. Стойностите трябва да са от един и същ тип.

Като например, нека разгледаме кода:

```js run
let arg = prompt("Добави стойност?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Едно или нула' );
    break;

  case '2':
    alert( 'Две' );
    break;

  case 3:
    alert( 'Никога не се изпълнява!' );
    break;
  default:
    alert( 'Незнайна стойност' );
}
```

1. За `0`, `1`, първия `alert` се изпълнява.
2. За `2` втория `alert` се изпълнява.
3. Но за `3`, резултата от `prompt` е стринг `"3"`, който не е стриктно равен `===` на числото `3`. Затова получаваме мъртъв код в `case 3`! `default` варианта ще се изпълни.
