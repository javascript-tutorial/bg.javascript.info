# Циклите: while и for

Често се налага да повтаряме някои действия.

Например, извеждане на стоки от списък една след друга или просто изпълняване на един и същ код за всяко число от 1 до 10.

*Циклите* са начин да повторите един и същ код няколко пъти.

## Цикълът "while"

Цикълът `while` има следния синтаксис:

```js
while (condition) { // условие
  // код
  // т.нар. "тяло на цикъл"
}
```

Когато `condition` e `true`, `код`-ът от тялото на цикъла ще се изпълни.

Например, следния цикъл ще изпринтира `i` докато `i < 3`:

```js run
let i = 0;
while (i < 3) { // ще изпринтира 0, после 1, после 2
  alert( i );
  i++;
}
```

Еднократно изпълнение на тялото на цикъла се нарича *итерация*. Цикълът в примера по-горе прави три итерации.

Ако `i++` беше липсвал в горния пример, цикълът би се повтарял (на теория) завинаги. На практика браузърът предоставя начини за спиране на такива цикли, а и в JavaScript, от сървърната страна, можем да убием процеса.

Всеки израз или променлива може да бъде условие на цикъл, а не само сравнения: условието се оценява и се превръща в булева стойност от `while`.

Например, по-късия вариант да пишем `while (i != 0)` е `while (i)`:

```js run
let i = 3;
*!*
while (i) { // когато i стане 0, условието става false и цикълът спира
*/!*
  alert( i );
  i--;
}
```

````smart header="Curly braces are not required for a single-line body"
Ако тялото на цикъла има една декларация, можем да пропуснем къдравите скоби `{…}`:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## Цикълът "do..while"

Проверката на условиет може да бъде преместена *под* тялото на цикъла с помощта на `do..while` синтаксиса:

```js
do {
  // тяло на цикъл
} while (condition); // условие
```

Цикълът първо ще изпълни тялото, след това ще провери състоянието и, докато то е `true`, ще го изпълнява отново и отново.

Например:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Тази форма на синтаксис трябва да се използва само, когато искате тялото на цикъла да се изпълни **най-малко веднъж** независимо от състоянието дали е `true` или `false`.  Обикновено се предпочита другата форма: `while(…) {…}`.

## Цикълът "for"

Цикълът `for` е малко по-сложен, но е и най-често използвания цикъл.

То изглежда така:

```js
for (begin; condition; step) { // начална стойност; условие: стъпка
  // ... тяло на цикъл ...
}
```

Нека научим значението на тези части с пример. Цикълът по-долу изпълнява `alert(i)` функцията `i` пъти като започва от `0` и при всяки итерация се увеличава до (но не включва) `3`:

```js run
for (let i = 0; i < 3; i++) { // ще изпринтира 0, после 1, после 2
  alert(i);
}
```

Нека да разгледаме `for` декларацията част по част:

| Част  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| начало | `i = 0`    | Изпълнява се веднъж при влизане в цикъла.                                      |
| условие | `i < 3`| Проверява се преди всяка итерация. Ако е невярно, цикълът спира.              |
| тяло | `alert(i)`| Изпълнява се отново и отново, докато състоянието е вярно.                         |
| стъпка | `i++`      | Изпълнява се след тялото при всяка итерация. |

Общия алгоритъм на цикъла работи така:

```
Започва изпълнение
→ (ако условието е вярно → изпълни тялото и стъпката)
→ (ако условието е вярно → изпълни тялото и стъпката)
→ (ако условието е вярно → изпълни тялото и стъпката)
→ ...
→ (ако условието е невярно → излиза/спира цикъла)
```

Тоест след всяка проверка на `условието`, `тялото` и `стъпката` се изпълняват.

Ако сте нови в циклите, може да ви помогне да се върнете към примера и да възпроизведете как работи стъпка по стъпка върху лист хартия.

Ето какво точно се случва в нашия случай:

```js
// for (let i = 0; i < 3; i++) alert(i)

// Започва изпълнение
let i = 0
// ако условието е вярно → изпълни тялото и стъпката
if (i < 3) { alert(i); i++ }
// ако условието е вярно → изпълни тялото и стъпката
if (i < 3) { alert(i); i++ }
// ако условието е вярно → изпълни тялото и стъпката
if (i < 3) { alert(i); i++ }
// (ако условието е невярно → излиза/спира цикъла)
// ... защото сега i == 3,а условието е i < 3
```

````smart header="Inline variable declaration"
Тука променливата "брояч" `i` е декларирана вътре в цикъла. Това се нарича "inline" деклариране на променлива т.е в самия ред. Такива променливи са видими само вътре в цикъла.

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // грешка, няма такава променлива
```

Вместо да дефинираме нова променлива, бихме могли да използваме съществуваща:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // използваме съществуваща променлива
  alert(i); // 0, 1, 2
}

alert(i); // 3, видима, защото е декларирана извън цикъла
```

````

### Пропускане на части

Всяка част от `for` може да се пропусне.

Например, можем да пропуснем `началото` ако не е нужно да правим нищо в началото на цикъла.

Като тук:

```js run
let i = 0; // имаме i декларирана и присвоена

for (; i < 3; i++) { // няма нужда от "начало"
  alert( i ); // 0, 1, 2
}
```

Също така можем да премахнем и частта `стъпка`:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

Това прави цикъла идентичен с `while (i < 3)`.

Всъщност можем да премахнем всичко, създавайки безкраен цикъл:

```js
for (;;) {
  // повтаря се безкрайно
}
```

Моля, обърнете внимание, че двете точки и запетаи `;` в `for` трябва да присъства. В противен случай ще има синтактична грешка.

## Прекъсване на цикъла

Обикновено цикълът излиза, когато състоянието му стане невярно `false`.

Но можем да принудим изхода му по всяко време с помощта на специалната директива `break`.

Например, цикълът по-долу пита потребителя за поредица от числа, "прекъсващи се", когато не се въвежда цифра:

```js run
let sum = 0;

while (true) {

  let value = +prompt("Въведете цифра", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Сума: ' + sum );
```

Директивата `break` е активирана в линията с `(*)` ако потребителят въведе празен ред или отмени въвеждането. Той спира цикъла веднага, предавайки контрола към първия ред след цикъла. А именно на `alert`.

Комбинацията "безкраен цикъл + `break` колкото е необходимо" е чудесен за ситуации, когато условието в цикъла трябва да се проверява не в началото или в края на цикъла, а в средата или дори на няколко места от тялото му.

## Продължаване към следващата итерация [#continue]

Директивата `continue` е "олекотената версия" на `break`. То не спира целия цикъл. Вместо това то спира текущата итерация и принуждава цикъла да започне наново (ако условието позволява).

Можем да го използваме, ако приключим с текущата итерация и бихме искали да преминем към следващата.

Цикълът по-долу използва `continue`, за да извежда само нечетните стойности:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // ако е `true`, пропуска останалата част на тялото
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, после 3, 5, 7, 9
}
```

За четните стойности на `i`, `continue` директивата спира изпълнението на тялото и подава контрола на следващата итерация на `for` (със следващата цифра). И така `alert` е повикан само за нечетни стойности.

````smart header="The `continue` directive helps decrease nesting"
Цикъл, който показва нечетни стойности, може да изглежда така:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

От техническа гледна точка това е идентично с горния пример. Със сигурност можем просто да сложим кода в блок от `if` вместо да използваме `continue`.

Но като страничен ефект, това създава още едно ниво на влагане (функцията `alert` се извиква вътре в къдравите скоби). Ако кодът вътре в `if` е по-дълъг от няколко реда това може да намали четимостта.
````

````warn header="No `break/continue` to the right side of '?'"
Моля, обърнете внимание, че тази конструкция на синтаксис, които не е израз, не могат да се използват с "ternary" оператора `?`. По-специално, директиви като "break / continue" не са разрешени там.

Например, ако вземем този код:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...и го пренапишете с помощта на въпросителен знак:


```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue не е разрешено тук
```

...спира да работи: има синтактична грешка.

Това е просто още една причина да не се използва "ternary" оператора "?" вместо "If".
````

## Етикети за break/continue

Понякога трябва да излезем от няколко вложени цикъла наведнъж.

Например, в кода по-долу ние циклим над `i` и `j`, подканваме за координатите `(i, j)` от `(0,0)` до `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Стойностите в координатите (${i},${j})`, '');

    // какво правим ако искаме да излезем от тука и искаме да извикаме функцията с "Готов" (по-долу)?
  }
}

alert('Готово!');
```

Имаме нужда от начин да спрем процеса, ако потребителят анулира въвеждането.

Обикновеният `break` след `input` би спрал само вътрешния цикъл.Но това не е достатъчно - тука идват етикетите за помощ!

*Етикетът* е идентификатор с двоеточие преди цикъла:
```js
labelName: for (...) { // Име на етикет
  ...
}
```

Кодът `break <ИмеНаЕтикет>` в цикъла по-долу спира цикъла обозначен с този етикет:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) { // Етикетът: outher

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Стойността в координатите (${i},${j})`, '');

    // ако е празен стринг или е отменен, ще спира и двете цикли
    if (!input) *!*break outer*/!*; // (*)

    // направете нещо със стойността...
  }
}
alert('Готово!');
```

В кода по-горе, `break outer` поглежда нагоре към етикета с име `outer` и спира този цикъл.

Така че контролът преминава направо от линията с `(*)` към `alert('Готово!')`.

Можем също да преместим етикета на отделен ред:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

Директивата `continue` също може да се използва с етикети. В този случай изпълнението на кода прескача до следващата итерация на етикетирания цикъл.

````warn header="Labels do not allow to \"jump\" anywhere"
Етикетите не ни позволяват да скочим на произволно място в кода.

Например, невъзможно е да направите това:
```js
break label; // не скача на етикета по-долу

label: for (...)
```

Извикването на `break/continue` е възможно само от вътрешен цикъл и етикетът трябва да е някъде над директивата.
````

## Обобщение

Покрихме 3 вида цикли:

- `while` -- Условието се проверява преди всяка итерация.
- `do..while` -- Условието се проверява след всяка итерация.
- `for (;;)` -- Условието се проверява преди всяка итерация, налични са допълнителни настройки.

За да направите "безкраен" цикъл, обикновенно се използва `while(true)` структурата. Такъв цикъл, както всеки друг, може да бъде спрян с директивата `break`.

Ако не искаме да правим нищо в текущата итерация и бихме искали да препратим към следващата, можем да използваме директивата `continue`.

`break/continue` поддържат етикети преди цикъла. Етикетът е единственият начин при `break/continue`, за да излизате от вложен цикъл и да отидете на външен.
