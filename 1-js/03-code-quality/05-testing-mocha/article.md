# Автоматизирано тестване с Mocha

Автоматизираното тестване ще се използва в бъдещите задачи и също така се използва широко в реални проекти.

## Защо имаме нужда от тестове?

Когато пишем функция, обикновено можем да си представим какво ще прави: кои параметри и какъв резултат ще се върнат.

По време на писането на кода можем да проверим функцията като я стартитаме и сравним резултата с очаквания. Например можем да направим това в конзолата. 

Ако някъде има грешка, оправяме кода, стартираме го отново, проверяваме резултата и така, докато оправим всички грешки.

Но тези ръчни "рестартирания" не са перфектни.

**Когато тестваме код на ръка е лесно да пропуснем нещо.**

Например, създаваме функция `f`. Пишем част от кода, тестваме: `f(1)` работи, но `f(2)` не работи. Оправяме кода и сега `f(2)` работи. Изглежда, че сме готови? Но забравихме да ретестваме `f(1)`. Това може да доведе до грешка.

Това е много типично. Когато разработваме нещо, ние обмисляме доста *use* кейсове. Но не можем да очакваме, че програмиста ще проверява всички кейсове ръчно след всяка промяна. Така че лесно може да се оправи един бъг и да се счупи нещо друго в кода. 

**При автоматичното тестване тестовете се пишат отделно от кода. Те тестват нашите функции и сравняват резултатите с очакваните такива.**

## Behavior Driven Development (BDD)

Нека започнем с техника, наречена [Behavior Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development) или накратко, BDD.

**BDD съдържа 3 неща в едно: тестове, документация и примери.**

За да разберем BDD, ние ще разгледаме практически пример на разработка на софтуер.

## Разработката на "pow" (функцията за повдигане на степен): спецификация

Да кажем, че искаме да направим функция `pow(x, n)` която повдига `x` до цяло число на степен `n`. Ние приемаме, че `n≥0`.

Тази задача е просто пример: В JavaScript има един оператор `**`, който може да направи това, но тук се концентрираме върху процеса на разработка, който може да се приложи и към по-сложни задачи.

Преди да напишем кода на `pow`, можем да си представим какво искаме да прави функцията и да го опишем.

Такова описание се нарича *спецификация* или накратко *specs* (спекс) и съдържа описание на *use* кейсове, заедно с тестовете за тях, като тези:

```js
describe("pow", function() {

  it("повдига до степен n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

Спецификацията има 3 основни части, които можете да видите горе:

`describe("title", function() { ... })`
: Каква функционалност описваме. В нашия случай описваме функцията `pow`. Използва се да групира "работници" -- блоковете `it`.

`it("use case description", function() { ... })`
: В заглавието на `it` ние описваме *на разбираем за човека език* конкретният *use* кейс, а вторият аргумент е функцията, която го тества.

`assert.equal(value1, value2)`
: Кодът вътре в `it` блока, ако имплементацията е точна, трябва да се изпълни без грешки.

    Функциите `assert.*` се използват да се провери дали `pow` работи както трябва. Тук използваме една от тях -- `assert.equal`, тя сравнява аргументите и ако не са равни, дава грешка. Тук проверява дали резултатът от  `pow(2, 3)` е равен на `8`. Има други видове сравнения и проверки, които ще добавим после.

Спецификацията може да се изпълни и ще стартира тестовете в `it` блока. Ще видим това по-късно.

## Етапи на разработката на софтуер

Етапите на разработка на софтуер обикновено изглеждат така:

1. Пише се начални спецификации с тестове за най-основната функционалност.
2. Прави се първоначална имплементация.
3. За да проверим дали работи, ние стартираме [Mocha](http://mochajs.org/) (скоро и повече детайли) която стартира спецификациите. Докато функционалността не е завършена, ще се появяват грешки. Ние правим промени, докато всичко започне да работи.
4. Сега имаме работеща начална функционалност с тестове.
5. Добавяме още *use* кейсове към спецификациите, които вероятно още не се поддържат от имплементацията. Тестовете започват да се чупят.
6. Връщаме се на стъпка 3, актуализираме имплементацията докато тестовете не дават вече грешки. 
7. Повтаряме стъпки 3-6 докато функционалността е готова.

Този вид разработване на софтуер, се нарича *итеративен*. Ние пишем спецификациите, имплементираме го, уверяваме се че тестовете минават и пишем още тестове, уверяваме се, че те също работят и т.н. Накрая имаме работеща имплементация и тестове към нея. 

Нека видим процеса на разработка в нашия практически пример.

Първата стъпка вече е готова: имаме начални спецификации за `pow`. Сега нека използване няколко JavaScript библиотеки, за да пуснем тестовете и да видим дали работят (те всички ще са неуспешни).

## Спецификациите в действие

В това ръководство ние ще използваме следните JavaScript библиотеки за тестовете:

- [Mocha](http://mochajs.org/) -- основният фреймуърк: тя осигурява основните тестови функции включително `describe` и `it` и основната функция, която стартира тестовете.
- [Chai](http://chaijs.com) -- библиотека с мното assertions (допускания). Тя позволява да използваме множество различни допускания, за сега ние имаме нужда само от `assert.equal`.
- [Sinon](http://sinonjs.org/) -- библиотека, която проследява функции, емулира вградени функции и още. Ще имаме нужда от нея по-късно.

Тези библиотеки са подходящи както за тестване в браузъра, така и за тестване на сървъра. Тук ще тестваме в браузъра. 

Цялата HTML страница с тези frameworks (рамки) и спецификациите за `pow`:

```html src="index.html"
```

Страницата може да се раздели на пет части:

1. `<head>` добавя библиотеки от трети страни и стилове за тестовете.
2. `<script>` съдържа кода на функцията, която ще тестваме, в нашия случай -- `pow`.
3. Тестовете, в нашия случай, във външен скрипт `test.js` който има `describe("pow", ...)`.
4. HTML елемент `<div id="mocha">` ще бъде използван от Mocha за да покаже резултатите от тестовете.
5. Тестовете стартират от командата`mocha.run()`.

Резултатът:

[iframe height=250 src="pow-1" border=1 edit]

За сега тестът е неуспешен зашото има грешка. Това е логично: имаме функция без код в `pow`, така че `pow(2,3)` връща `undefined` вместо `8`.

За в бъдеще нека отбележим, че има много по-добри фреймуърци за тестване, като [karma](https://karma-runner.github.io/) и други, с които е по-лесно да се пуснат автоматично множество различни тестове.

## Първоначална имплементация

Нека направим проста имплементация на `pow`, за да минат тестовете:

```js
function pow(x, n) {
  return 8; // :) ние измамихме!
}
```

Уау, сега работи!

[iframe height=250 src="pow-min" border=1 edit]

## Подобрение на спецификациите

Това, което направихме наистина е измама. Функцията не работи: при опит да изчислим `pow(3,4)` ще получим грешен резултат, но теста ще мине.

...Но тази ситуация е доста типична, случва се в практиката. Тестовете са успешни, но функцията не работи правилно. Нашата спецификация не е завършена. Ще трябва да добавим още *use* кейсове към нея.

Нека добавим още един тест който проверява, че `pow(3, 4) = 81`.

Може да изберем един от двата начина да организираме тестовете тук:

1. Първи вариант -- добавяме още един `assert` в същия `it`:

    ```js
    describe("Степен", function() {

      it("повдигнато до n-та степен", function() {
        assert.equal(pow(2, 3), 8);
    *!*
        assert.equal(pow(3, 4), 81);
    */!*
      });

    });
    ```
2. Вторият -- да напишем два теста:

    ```js
    describe("Степен", function() {

      it("2 повдигнато на 3-та степен е 8", function() {
        assert.equal(pow(2, 3), 8);
      });

      it("3 повдигнато на 4-та степен е 81", function() {
        assert.equal(pow(3, 4), 81);
      });

    });
    ```

Основната разлика е че когато `assert` предизвика грешка, изпълнението на `it`  блока спира веднага. Така че при първия вариант ако първият `assert` не мине, никога няма да видим резултата от втория `assert`.

Писането на отделни тестове е полезно, за да получим повече информация за това какво се случва, така че вторият вариант е по-добър.

Освен това има още едно правило, което е добре да следваме.

**Един тест проверява едно нещо.**

Ако погледнем един тест и видим две независими проверки в него, по-добре е да го разделим на два по-прости теста.

Нека продължим с втория вариант.

Резултатът:

[iframe height=250 src="pow-2" edit border="1"]

Както можеше да се очаква, вторият тест е неуспешен. Естествено, нашата функция винаги връща `8`, докато `assert` очаква `81`.

## Подобряване на имплементацията

Нека напишем някакъв по-реалистичен код, за да минат тестовете:

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

За да сме сигурни, че функцията работи добре, нека я тестваме с повече стойности. Вместо да пишем `it` блокове ръчно, можем да ги генерираме във `for`:

```js
describe("Степен", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} на 3-та степен е ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

Резултатът:

[iframe height=250 src="pow-3" edit border="1"]

## Вложен/и describe

Ние ще добавим още тестове. Но преди това нека отбележим, че помощната функция `makeTest` и `for` трябва да се групират заедно. Няма нужда от `makeTest` в другите тестове, тя ни трябва само във `for`: тяхната обща задача е да проверят как `pow` повдига число на дадена степен.

Групирането се прави с вложен `describe`:

```js
describe("pow", function() {

*!*
  describe("повдига x на степен 3", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} на степен 3 е ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... тук ще бъдат добваени още тестове, може да се използват describe и it
});
```

Вложеният `describe` дефинира нова "подгрупа" от тестове. В резултатите може да видим че тя е отместена навътре:

[iframe height=250 src="pow-4" edit border="1"]

В бъдеще можем да добавим още `it` и `describe` на горното ниво със собствени помощни функции. Те няма да виждат `makeTest`.

````smart header="`before/after` и `beforeEach/afterEach`"
Може да използваме `before/after` функции, които се изпълняват преди/след пускането на тестовете, и също `beforeEach/afterEach` функции, които се изпълняват преди/след *всеки* `it`.

Например:

```js no-beautify
describe("Тест", function() {
  
  before(() => alert("Начало на тестването – преди всички тестове"));
  after(() => alert("Край на тестването – след всички тестове"));

  beforeEach(() => alert("Преди теста – влизаме в тест"));
  afterEach(() => alert("След теста – излизаме от тест"));

  it('Тест 1', () => alert("Това е: Тест 1"));
  it('Тест 2', () => alert("Това е: Тест 2"));

});
```

Последователността на изпълнение ще бъде:

```
Начало на тестването – преди всички тестове (before)

Преди теста – влизаме в теста (beforeEach)
Това е: Тест 1 (it)
След теста – излизаме от тест (afterEach)

Преди теста – влизаме в тест (beforeEach)
Това е: Тест 2 (it)
След теста – излизаме от тест (afterEach)

Край на тестването – след всички тестове (after)
```

**ЗАБЕЛЕЖКА**: Ако тестовете не минават в горния пример, това е заради това че *mocha* по подразбиране чака 2 секунди преди да реши че тестът не минава. За да го избегнете това можете да използвате метода timeout за да го промените, ето така:

```js no-beautify
describe("Тест", function() {

  // timeout приема като параметър число в милисекунди - в случая 200 000 => 200секунди
  this.timeout(200000); // С тази функция променяме това поведение на mocha

  before(() => alert("Начало на тестването – преди всички тестове"));
  after(() => alert("Край на тестването – след всички тестове"));

  beforeEach(() => alert("Преди теста – влизаме в тест"));
  afterEach(() => alert("След теста – излизаме от тест"));

  it('Тест 1', () => alert("Това е: Тест 1"));
  it('Тест 2', () => alert("Това е: Тест 2"));

});
```


[edit src="beforeafter" title="Open the example in the sandbox."]

Обикновено, `beforeEach/afterEach` и `before/after` се използват да се направи инициализация, да се занулят броячи или да се направи нещо друго между тестовете (или тестовите групи).


## Разширяване на спецификацията

Основната функционалност на `pow` е завършена. Първата итерация от разработването е готова. Като приключим с празненствата и пиенето на шампанско -- нека да я подобрим.

Както казахме, функцията `pow(x, n)` е предназначена да работи с цели положителни числа `n`.

За да посочи математическа грешка, функциите в JavaScript обикновено връщат `NaN`. Нека направим същото за невалидни стойности на `n`.

Нека първо добавим това поведение в спецификациите(!):

```js
describe("Степен", function() {

  // ...

  it("Ако n e отрицателен, резултатът е NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("Ако n e дробно число, резултатът е NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

Резултатът с новите тестове:

[iframe height=530 src="pow-nan" edit border="1"]

Новодобавените тестове ще са неуспешним защото нашата имплементация не ги поддържа. Така се прави BDD: първо пишем тестове, които не минават и после правим тяхната имплементация.

```smart header="Други допускания"
Обърнете внимание на допускането `assert.isNaN`: то проверява за `NaN`.

Има и други допускания в [Chai](http://chaijs.com), например:

- `assert.equal(value1, value2)` -- проверява за равенство `value1 == value2`.
- `assert.strictEqual(value1, value2)` -- проверява за абсолютно равенство `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` -- проверява за неравенство.
- `assert.isTrue(value)` -- проверява дали стойността е истина `value === true`
- `assert.isFalse(value)` -- проверява дали стойността е неистина `value === false`
- ...пълният списък е на [docs](http://chaijs.com/api/assert/)
```

Така че трябва да добавим няколко реда към `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

Сега работи и всички тестове са успешни:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="Open the full final example in the sandbox."]

## Обобщение

В BDD спецификацията винаги е първа, следвана от импелментацията. Накрая имаме спецификация и код към нея.

Спецификацията може да се използва по три начина:

1. Като **Тестове** - те гарантират, че кода работи правилно.
2. Като **Документация** -- заглавията на `describe` и `it` казват какво прави функцията.
3. Като **Примери** -- тестовете всъщност са работещи примери, които показват как да се използа функцията.

Със спецификациите ние безопасно можем да подобрим, променим или дори пренапишем функцията и тя пак да работи правилно. 

Това е особено важно за големи проекти, където функцията се използва на много места. Когато променим тази функция, просто няма начин да проверим ръчно всички места където се използва, за да сме сигурни, че още работи правилно.

Без тестове хората имат два начина:

1. Да направят промяната въпреки всичко. И тогава нашите потребители се натъкват на бъгове, тъй като ние най-вероятно не сме успели да проверим всичко на ръка.
2. Ако наказанията за грешки са твърде строги, понеже няма тестове, хорта се страхуват да променят такива функции и тогава кодът става остарял, и никой не иска да се занимава с него. Това не е добре за разработването. 

**Автоматизираното тестване помага да се избегнат такива проблеми!**

Ако проектът е покрит от тестове, няма такъв проблем. След всяка промяна можем да пуснем тестовете и да направим множество проверки за секунди.

**Освен това добре тестван код има по-добра архитектура.**

Естествено, това е така защото код, който се тества автоматично, е по-лесен за променяне и подобряване. Но има и друга причина. 

За да пишем тестове, кодът трябва да е организиран по такъв начин, че всяка функция да има ясно описана задача с добре дефинирани входни и изходни данни.Това означава добра архитектура от самото начало.

В истинския живот това не е толкова лесно. Понякога е трудно да напишете спецификацията преди кода, защото все още не е ясно как трябва да се работи. Но по правило писането на тестове прави процеса на разработка по-бърз и по-стабилен. 

По-късно в ръководството ще видите много задачи с тестове към тях. Така че ще видите повече практически примери.

Писането на тестове изисква добро познаване на JavaScript. Но ние сега започваме да го изучаваме. Така че за сега от вас не се изисква да пишете тестове, но вече би трябвало да можете да ги разчитате, дори и да са малко по-сложни от тестовете в тази глава. 
