# Основен синтаксис на класовете

```quote author="Уикипедия"
В обектно-ориентираното програмиране, *клас* е разширяем програмен код-шаблон за създаване на обекти, осигурявайки първоначални стойности за състоянието(свойствата) и имплементациите на поведението(функциите и методите).
```

На практика често ни се налага да създаваме много обекти от един и същи вид, като потребители, стоки или каквото и да било.

Както вече знаем от главата <info:constructor-new>, `new function` може да помогне с това.

Но в модерния JavaScript, има по-напреднал конструктор за "класовете" , което въвежда страхотни нови функции, които са полезни за обектно-ориентирано програмиране

## Синтаксис на "клас"

Основният синтаксис е:
```js
class MyClass {
  // методи на класа
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

После използваме `new MyClass()` за да създадем нов обект с всички изброени методи.

Методът `constructor()` се извиква автоматично от `new`, за да можем да инициализираме обекта.

Например:

```js run
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Употреба:
let user = new User("John");
user.sayHi();
```

Когато `new User("John")` е извикано:

1. Създава се нов обект.
2. Извиква се `constructor`, което работи с дадения аргумент и присвоява `this.name` към обекта.

...Тогава можем да извикнем обектни методи, като например `user.sayHi()`.


```warn header="Няма запетая между методите на класа"
Често срещан проблем при начинаещите разработчици е да поставят запетая между методите на класа, което би довело до грешка в синтаксиса.

Обозначението тук не трябва да се бърка с литералите обектите. В рамките на класа не се изискват запетаи.
```

## Какво е клас?

Така, какво точно е `клас`? Това не е съвсем изцяло нова единица на езиково ниво, както някои могат да си помислят.

Нека разкрием всяка магия и да видим какво всъщност представлява клас. Това ще помогне за разбирането на много сложни аспекти.

В JavaScript, клас е вид функция.

Ето, погледнете:

```js run
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// доказателство: Потребителят е функция
*!*
alert(typeof User); // функция
*/!*
```

Ето какво точно прави `class User {...}` конструкторът:

1. Създава функция с име `User`, това става резултат от декларацията за клас. Функционалният код се взема от `constructor` метода (приема се празен, ако не напишем такъв метод).
2. Съхранява методи на класа, като например `sayHi`, в `User.prototype`.

След като `new User` обекта е създаден, когато извикаме неговия метод, то се взима от прототипа, точно както е описано в главата <info:function-prototype>. Така обектът има достъп до методите на класа.

Можем да илюстрираме резултата от `class User` декларацията:

![](class-user.svg)

Ето код за интроспекция:

```js run
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// класът е функция
alert(typeof User); // функция

// ...или, по-точно, методът на конструктора
alert(User === User.prototype.constructor); // true

// Методите са в User.prototype:
alert(User.prototype.sayHi); // alert(this.name);

// има точно два метода в User.prototype
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

## Не е просто синтактична захар

Понякога хората казват, че `class` е "синтактична захар" (синтаксис, който е предназначен да улесни нещата за четене, но не въвежда нищо ново), защото всъщност бихме могли да декларираме същото без ключовата дума `class`:

```js run
// пренаписване на клас Потребител с "pure" функции

// 1. Създайте функция конструктор
function User(name) {
  this.name = name;
}
// прототипът на функция има свойство "constructor" по подразбиране,
// така че няма нужда да го създаваме

// 2. Добавете метода към прототипa
User.prototype.sayHi = function() {
  alert(this.name);
};

// Употреба:
let user = new User("John");
user.sayHi();
```

Резултатът от това определение е приблизително същия. Така че, наистина има причини `class` може да се счита за синтактична захар за дефиниране на конструктор заедно с неговите методи на прототип.

Все пак има важни разлики.

1.Първо функция, създадена от `class` е обозначен със специален вътрешно свойство `[[FunctionKind]]:"classConstructor"`. Така че не е напълно същото като създаването му ръчно.

    Езикът проверява за това свойство на различни места. Например, за разлика от обикновената функция, тя трябва да бъде извикана с `new`:

    ```js run
    class User {
      constructor() {}
    }

    alert(typeof User); // function
    User(); // Error: Class constructor User cannot be invoked without 'new'
            // Грешка: Конструкторът на класa User не може да бъде извикан без "new"
    ```

   Също така, низовото представяне на конструктор а на класа в повечето JavaScript двигатели започва с "class..."

    ```js run
    class User {
      constructor() {}
    }

    alert(User); // class User { ... }
    ```
    Има и други разлики, ще ги видим скоро.

1. Методите на класа не са изброими.
    Дефиницията на класа поставя `enumerable` флаг на `false` за всички методи в `"prototype"`.

    Това е добре, защото ако ние изциклим с `for..in` над обект, обикновено не искаме методите му.

2. Класовете винаги използват `use strict`.
    Целият код в рамките на конструкта на класа автоматично е в строг режим.

Освен това, `class` синтаксисът носи много други функции, които ще проучим по-късно.

## Израз на класа

Също като функциите, класовете могат да бъдат определени в друг израз, да бъдат подавани наоколо, да бъдят връщани, да бъдят присвоявани, и т.н. .

Ето пример за израз на клас:

```js
let User = class {
  sayHi() {
    alert("Hello");
  }
};
```

Подобно на "Named Function Expression" (наименуваните изрази на функциите), изразите на класовете могат да имат име.

Ако изразът на класа има име, то е видимо само отвътре в класа:

```js run
// "Named Class Expression" - Наименуван израз на клас
// (няма такъв термин в спецификацията, но това е подобно на Named Function Expression)
let User = class *!*MyClass*/!* {
  sayHi() {
    alert(MyClass); // Името MyClass се вижда само в класа
  }
};

new User().sayHi(); // работи и показва дефиницията за MyClass

alert(MyClass); // грешка, името MyClass не е видимо извън класа
```

Можем дори да правим класове динамично "при поискване", като този:

```js run
function makeClass(phrase) {
  // декларираме клас и го връщаме
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// СЪздаваме нов клас
let User = makeClass("Hello");

new User().sayHi(); // Hello
```

## Getters/setters

Точно като литералните обекти, класовете могат да включват getters / setters (методи, които връщат свойствата на обекта или присвояват им данни по специален контролиран начин), изчислени свойства и др. .

Ето пример за имплементацията на `user.name` използвайки методите `get/set`:

```js run
class User {

  constructor(name) {
    // извиква setter метода
    this.name = name;
  }

*!*
  get name() {
*/!*
    return this._name;
  }

*!*
  set name(value) {
*/!*
    if (value.length < 4) {
      alert("Името е твърде кратко!");
      return;
    }
    this._name = value;
  }

}

let user = new User("John");
alert(user.name); // John

user = new User(""); // Името е твърде кратко!
```

Технически, такава декларация на клас работи чрез създаване на getters и setters в `User.prototype`.

## Изчислени имена [...]

Ето пример с изчислено име на метод, използвайки квадратните скоби `[...]`:

```js run
class User {

*!*
  ['say' + 'Hi']() {
*/!*
    alert("Hello");
  }

}

new User().sayHi();
```

Такива функции са лесни за запомняне, тъй като наподобяват тези на литералните обекти.

## Полетата на класа

```warn header="Старите браузъри може да се нуждаят от polyfill"
Полетата на класа са скорошно допълнение към езика.
```

Преди това нашите класове имаха само методи.

"Поле на клас" е синтаксис, който позволява да се добавят всякакви свойства.

Например, нека да добавим свойството `name` на `class User`:

```js run
class User {
*!*
  name = "John";
*/!*

  sayHi() {
    alert(`Здравей, ${this.name}!`);
  }
}

new User().sayHi(); // Здравей, John!
```

И така, ние просто пишем "свойство" = "стойност" в декларацията, и това е всичко.

Важната разлика на класовите полета е, че те са зададени на отделни обекти, а не на `User.prototype`:

```js run
class User {
*!*
  name = "John";
*/!*
}

let user = new User();
alert(user.name); // John
alert(User.prototype.name); // undefined
```

Можем също да присвояваме стойности, като използваме по-сложни изрази и извиквания на функции:

```js run
class User {
*!*
  name = prompt("Името Ви моля?", "John");
*/!*
}

let user = new User();
alert(user.name); // John
```

### Осъществяване на обвързани методи с полетата класа

Както е показано в главата <info:bind> функциите в JavaScript имат динамичен `this`. Зависи от контекста на извикването.

Така че, ако методът на обекта се предава и се извиква в друг контекст, `this` вече няма да реферира към обекта си.

Например, този код ще покаже `undefined`:

```js run
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button("hello");

*!*
setTimeout(button.click, 1000); // undefined
*/!*
```

Проблемът се нарича "губене на `this`".

Има два подхода за отстраняването му, както е обсъдено в главата <info:bind>:

1. Предайте функция-обвивка, като тук: `setTimeout(() => button.click(), 1000)`.
2. Обвържете метода с обекта, напр. в конструктора.

Полетата на класовете предоставят друг, доста елегантен синтаксис:

```js run
class Button {
  constructor(value) {
    this.value = value;
  }
*!*
  click = () => {
    alert(this.value);
  }
*/!*
}

let button = new Button("hello");

setTimeout(button.click, 1000); // hello
```

Полето на класа `click = () => {...}` се създава на базата на обекта, има отделна функция за всеки `Button` обект, с `this` вътре в него, отнасящ се до този обект. Можем да подадем `button.click` навсякъде, и стойността на `this` винаги ще бъде правилна.

Това е особено полезно в средата на браузъра за хващане на събитията.

## Обобщение

Синтаксисът на обикновения клас изглежда така:

```js
class MyClass {
  prop = value; // свойство

  constructor(...) { // конструктор
    // ...
  }

  method(...) {} // методи/функции

  get something(...) {} // getter метод
  set something(...) {} // setter метод

  [Symbol.iterator]() {} // метод/функця с изчислено име (тук е символ)
  // ...
}
```

`MyClass` технически е функция (тази, която предоставяме като `constructor`), докато методите, функциите, getter и setter методите са записани в `MyClass.prototype`.

В следващите глави ще научим повече за класовете, включително наследяване и други характеристики.
