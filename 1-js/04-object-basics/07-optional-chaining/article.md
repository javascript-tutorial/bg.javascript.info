
# Поизборна верига '?.'

[recent browser="new"]

Поизборната верига `?.` е доказан начин за защита от грешки при достъп до свойства на вложени обекти, дори ако междинното свойство не съществува.

## Проблемът

Ако токущо Ако току-що сте започнали да четете ръководството и да научите JavaScript, може би още не сте се срещнали с проблема, но то е доста често срещан.

Например, някои от нашите потребители имат адреси, но малцина не ги предоставят. Тогава не можем безопасно да четем `user.address.street`:

```js run
let user = {}; // потребителят е без адрес

alert(user.address.street); // Грешка!
```

Или, в уеб разработката, бихме искали да получим информация за елемент от страницата, но то може да не съществува:

```js run
// Грешка, ако резултатът от querySelector(...) е null
let html = document.querySelector('.my-element').innerHTML;
```

Преди `?.` да се появи в езика, операторът `&&` беше използван да работи около това.

Например:

```js run
let user = {}; // потребителят е без адрес

alert( user && user.address && user.address.street ); // undefined (Няма грешка)
```

И целият път до свойството гарантира, че всички компоненти съществуват, но е тромаво за писане.

## Поизборна верига

Поизборната верига `?.` спира веригата и връща `undefined` ако парчето преди `?.` е `undefined` или `null`.

**По-нататък в тази статия, за краткост, ще кажем, че нещо "съществува" ако не е `null` или `undefined`.**

Ето сигурния начин за достъп `user.address.street`:

```js run
let user = {}; // потребителят е без адрес

alert( user?.address?.street ); // undefined (Няма грешка)
```

Прочетенето на адреса с `user?.address` работи дори ако не съществува `user` обекта:

```js run
let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
```

Моля обърнете внимание: синтаксисът `?.` работи точно там, където е поставен, но не повече.

В горния пример, `user?.` позволява само `user` да е `null/undefined`.

От друга страна, ако `user` не съществува, тогава то трябва да има свойството `user.address`, иначе `user?.address.street` ще даде грешка след втората точка.

```warn header="Не прекалявайте с поизборната верига"
Трябва да използваме `?.` само когато е добре, че нещо не съществува.

Например, ако според нашата логика в кода, обекта `user` трябва да е там, но `address` е по-избор, тогава `user.address?.street` би било по-добре.

Така че, ако `user` по някаква грешка е `undefined`, ще знаем за това и ще го оправим. Иначе, грешки в кода могат да бъдат заглушени, когато не е подходящо, и ще стават по-трудни за отстраняване.
```

````warn header="Променливата преди `?.` трябва да съществува!"
Ако не съществуваше променлива `user`, тогава `user?.anything` задейства грешка:

```js run
// ReferenceError: user is not defined
// Грешка при рефериране: user не съществува
user?.address;
```

Поизборната верига работи само с **декларираните** променливи!
````

## Short-circuiting или т.нар Късо съединение

Както беше казано преди, `?.` веднага спира ("късо съединение") изпълнението ако лявата част не съществува.

Така че, ако има допълнителни функции или странични реакции, те не се появяват:

```js run
let user = null;
let x = 0;

user?.sayHi(x++); // нищо не се случва

alert(x); // 0, стойност не се увеличава
```

## Други случаи: ?.(), ?.[]

Поизборната верига `?.` не е оператор, но специална синтаксична конструкция,който също работи с функции и квадратни скоби.

Например, `?.()` се използва за извикване на функция, която може да не съществува.

В кода по-долу, някои от нашите потребители имат функция `admin`, а някои нямат:

```js run
let user1 = {
  admin() {
    alert("Аз съм админ");
  }
}

let user2 = {};

*!*
user1.admin?.(); // Аз съм админ
user2.admin?.();
*/!*
```

Тук и в двата реда първо използваме точката `.`, за да получим свойство `admin`, тъй като потребителският обект трябва да съществува, така че да е безопасно да се чете от него.

Тогава `?.()` проверява лявата част: ако админ функцията съществува, тогава я тече (`user1`). Иначе (`user2`) изпълнението спира без грешки.

Синтаксиса `?.[]`също работи, ако искаме да използваме скоби `[]` за достъп до свойства вместо точка `.`. Подобно на предишните случаи, то позволява безопасно да чете свойство от обект, който може да не съществува.

```js run
let user1 = {
  firstName: "John"
};

let user2 = null; // Представете си, не можахме да упълномощим потребителя

let key = "firstName";

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```

Също така можем да използваме `?.` с `delete`:

```js run
delete user?.name; // Изтриваме свойството user.name ако user съществува
```

```warn header="Можем да използваме `?.` за безопасно четене и изтриване, но не и писане"
Поизборната верига `?.` няма употреба в лявата част на заданието:

```js run
// идеята на кода по-долу е да напишете user.name, ако потребителят съществува

user?.name = "John"; // Грешка, не работи
// защото undefined = "John"
```

## Обобщение

Синтаксисът `?.` име три форми:

1. `обект?.свойство` -- връща свойството `обект.свойство` ако `обект` съществува, в противен случай `undefined`.
2. `обект?.[свойство]` -- връща свойството `обект[свойство]` ако `обект` съществува, в противен случай `undefined`.
3. `обект?.функция()` -- извиква функцията `обект.функция()` ако `обект` съществува, в противен случай връща `undefined`.

Както виждаме, всички те са лесни и прости за използване. `?.` проверява лявата част за `null/undefined` и позволява изпълнението да продължи, ако не е така.

Врига от `?.` позволява безопасен достъп до вложени свойства.

Все още, трябва да използваме `?.` внимателно, само когато е добре, че лявата част не съществува.

За да не скрие програмните грешки от нас, ако се появят.
