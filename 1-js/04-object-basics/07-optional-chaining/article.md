
# Поизборна верига '?.'

[recent browser="new"]

Поизборната верига `?.` е доказан начин за защита от грешки при достъп до свойства на вложени обекти, дори ако междинното свойство не съществува.

## Проблемът на "несъществуващото свойство"

Ако току-що сте започнали да четете ръководството и да научите JavaScript, може би още не сте се срещнали с проблема, но то е доста често срещан.

<<<<<<< HEAD
Като пример, нека да кажем, че имаме обекти `user`, които държат информация относно нашите потребители.
=======
As an example, let's say we have `user` objects that hold the information about our users.
>>>>>>> c56e6a57ac3497aab77128c5bfca13513980709b

Повечето от нашите потребители са адресирани в свойството `user.address`, с улица`user.address.street`, но някои от тях не са ги предоставили.

При подобно ситуация, когато опитаме да вземем стойността от `user.address.street`, и се окаже, че потребителят е без адрес, ние ще получим грешка:

```js run
let user = {}; // обекта `user` без свойството "address"

alert(user.address.street); // Грешка!
```

<<<<<<< HEAD
Това е очакваният резултат. JavaScript работи така. Като `user.address` е `undefined`, при опит за взимане стойността на `user.address.street` се проваля с грешка.
=======
That's the expected result. JavaScript works like this. As `user.address` is `undefined`, an attempt to get `user.address.street` fails with an error.
>>>>>>> c56e6a57ac3497aab77128c5bfca13513980709b

В много практически случаи бихме предпочели да получим `undefined` вместо грешка тук (означаващ "няма улица").

...И още един пример. В Уеб разработката, можем да получим обект, който съответства на елемент от уеб страницата, чрез извикване със специален метод, като `document.querySelector('.elem')`, която изисква аргумент за намиране на дадения елемент, и ще връща `null` когато този елемент не е намерен или несъществува.

```js run
// document.querySelector('.elem') е `null` ако няма такъв елемент
let html = document.querySelector('.elem').innerHTML; // грешка ако то е `null`
```

Още веднъж, ако елементът не съществува, ще получим грешка при опит за достъп свойстово `.innerHTML` на `null` обект. И в някои случаи, когато отсъствието на елемента е нормално, бихме искали да избегнем грешката и просто да приемем `html = null` като резултат.

Как бихме могли да направим това?

Очевидното решение би било да се провери стойността с помощта `if` или условния оператор `?`, преди да осъществим достъп до свойството, подобно на това:

```js
let user = {};

alert(user.address ? user.address.street : undefined);
```

Работи, няма грешки... Но е доста неелегантно. Както виждате, `"user.address"` се появява два пъти в кода. За по-дълбоко вложени свойства това се превръща в проблем, тъй като се изискват повече повторения.

Напр. нека опитаме да получим `user.address.street.name`.

Трябва да проверим `user.address` и `user.address.street`:

```js
let user = {}; // `user` няма адрес

alert(user.address ? user.address.street ? user.address.street.name : null : null);
```

<<<<<<< HEAD
Това е просто ужасно, дори някои могат да има проблеми с разбирането на такъв код.
=======
That's just awful, one may even have problems understanding such code.
>>>>>>> c56e6a57ac3497aab77128c5bfca13513980709b

Всъщност не ни пука, тъй като има по-добър начин да го напишем използвайки оператора `&&`:

```js run
let user = {}; // потребителят е без адрес

alert( user.address && user.address.street && user.address.street.name ); // undefined (Няма грешка)
```

Целият път до свойството гарантира, че всички компоненти съществуват (ако не, условието спира), но също така и това не е идеалния начин.

Както виждате, имената на свойствата все още се дублират в кода. Например в горния код, `user.address` се появява 3 пъти.

Ето защо поизборна верига `?.` бе добавен към езика. За да разрешите този проблем веднъж завинаги!

## Поизборна верига

Поизборната верига `?.` спира веригата, ако парчето преди `?.` е `undefined` или `null` и връща тази част.

**По-нататък в тази статия, за краткост, ще кажем, че нещо "съществува" ако не е `null` или `undefined`.**

С други думи, `value?.prop`:

- е същото като `value.prop` ако `value` съществува,
- иначе (когато `value` е `undefined/null`) връща `undefined`.

Ето ви сигурния начин за достъп до `user.address.street` използвайки `?.`:

```js run
let user = {}; // потребителят е без адрес

alert( user?.address?.street ); // undefined (Няма грешка)
```

Кодът е кратък и изчистен, общо взето няма дублиране.

Прочетенето на адреса с `user?.address` работи дори ако не съществува `user` обект:
Reading the address with `user?.address` works even if `user` object doesn't exist:

```js run
let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
```

Моля обърнете внимание: синтаксисът `?.` работи точно там, където е поставен, но не повече.

Например в `user?.address.street.name` операторът `?.` позволява обекта `user` да бъде `null/undefined`, и това е всичко, което прави.Достъпът до други свойства се извършва по обикновения начин.Ако искаме някои от тях да са по избор, тогава ще трябва да замените още `.` с оператора `?.`.

```warn header="Не прекалявайте с поизборната верига"
Трябва да използваме `?.` само когато е добре, че нещо не съществува.

Например, ако според нашата логика в кода, обекта `user` трябва да е там, но `address` е по-избор, тогава `user.address?.street` би било по-добре.

Така че, ако `user` по някаква грешка е `undefined`, ще знаем за това и ще го оправим. Иначе, грешки в кода могат да бъдат заглушени, когато не е подходящо, и ще стават по-трудни за отстраняване.
```

````warn header="Променливата преди `?.` трябва да съществува!"
Ако не съществуваше променлива `user`, тогава `user?.anything` задейства грешка:

```js run
// ReferenceError: user is not defined
// Грешка при рефериране: user не съществува
user?.address;

```

Променливата трябва да бъде декларирана (например `let/const/var user` или като параметър на функция). Поизборната верига работи само с **декларираните** променливи!
````

## Short-circuiting или т.нар Късо съединение

Както беше казано преди, `?.` веднага спира ("късо съединение") изпълнението ако лявата част не съществува.

Така че, ако има допълнителни функции или странични реакции, те не се появяват.

Например:

```js run
let user = null;
let x = 0;

user?.sayHi(x++); // несъществува "sayHi", така изпълнението не достига `x++`

alert(x); // 0, стойност не се увеличава
```

## Други случаи: ?.(), ?.[]

Поизборната верига `?.` не е оператор, но специална синтаксична конструкция,който също работи с функции и квадратни скоби.

Например, `?.()` се използва за извикване на функция, която може да не съществува.

В кода по-долу, някои от нашите потребители имат функция `admin`, а някои нямат:

```js run
let userAdmin = {
  admin() {
    alert("Аз съм админ");
  }
};

let userGuest = {};

*!*
userAdmin.admin?.(); // Аз съм админ
userGuest.admin?.(); // нищо (няма подобен метод)
*/!*
```

Тук и в двата реда първо използваме точката (`userAdmin.admin`) за да вземем свойството `admin`, защото обекта на потребителя трябва да съществува, така че то да е безопасно за четене от него.

Тогава `?.()` проверява лявата част: ако съществува функция `admin`, я изпълнява (това е така и за `userGuest`). Иначе (за `userGuest`) изпълнението спира без грешки.

Синтаксиса `?.[]`също работи, ако искаме да използваме скоби `[]` за достъп до свойства вместо точка `.`. Подобно на предишните случаи, то позволява безопасно да четем свойство от обект, който може да не съществува.

```js run
let user1 = {
  firstName: "John"
};

let user2 = null; // Представете си, не можахме да упълномощим потребителя

let key = "firstName";

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```

Също така можем да използваме `?.` с `delete`:

```js run
delete user?.name; // Изтриваме свойството user.name ако user съществува
```

````warn header="Можем да използваме `?.` за безопасно четене и изтриване, но не за писане"
Поизборната верига `?.` няма употреба в лявата част на заданието:

Например:
```js run
let user = null;

user?.name = "John"; // Грешка, не работи
// защото undefined = "John"
```
Просто не работи толкова умно.
````

## Обобщение

Синтаксисът `?.` име три форми:

1. `обект?.свойство` -- връща свойството `обект.свойство` ако `обект` съществува, в противен случай `undefined`.
2. `обект?.[свойство]` -- връща свойството `обект[свойство]` ако `обект` съществува, в противен случай `undefined`.
3. `обект?.функция()` -- извиква функцията `обект.функция()` ако `обект` съществува, в противен случай връща `undefined`.

Както виждаме, всички те са лесни и прости за използване. `?.` проверява лявата част за `null/undefined` и позволява изпълнението да продължи, ако не е така.

Верига от `?.` позволява безопасен достъп до вложени свойства.

Все още, трябва да използваме `?.` внимателно, само когато е допустимо, че лявата част на извикването не съществува, за да не скрие програмните грешки от нас, ако се появят.
