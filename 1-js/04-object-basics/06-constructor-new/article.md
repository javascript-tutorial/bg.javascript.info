# Конструктор, операторът "new"

Обикновения синтаксис с `{...}` позволява да се създаде един обект. Но често трябва да създаваме много подобни обекти, като множество потребители или елементи от менюто и т.н.

Това може да стане с помощта на конструкторски функции и с оператора `"new"`.

## Функция на конструктора

Конструкторските функции технически са обикновенни функции. Обаче има две конвенции:

1. Те са кръстени с главна буква.
2. Те трябва да бъдат изпълнени само с `"new"` оператора.

Например:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Когато функцията се изпълнява с `new`, тя прави следните стъпки:

1. Създава се и се присвоява нов празен обект към `this`.
2. Тялото на функцията се изпълнява. То обикновено модифицира `this` като добавя нови свойства към него.
3. Стойността на `this` се връща.

С други думи, `new User(...)` прави нещо подобно:

```js
function User(name) {
*!*
  // this = {};  (имплицитно)
*/!*

  // добавя свойства на this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (имплицитно)
*/!*
}
```

Кодът `let user = new User("Jack")` дава същия резултат като на:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

Сега ако искаме да създадем други потребители можем просто да извикваме `new User("Ann")`, `new User("Alice")` и т.н. . Много по-кратко от използването на литерали всеки път, а също и лесен за четене.

Това е основната цел на конструктора -- да имплементира преизползваем код за създаване на обекти

Нека да отбележим още веднъж -- технически всяка функция може да се използва като конструктор. Това е: всяка функция може да се изпълни с `new`, и то ще изпълни алгоритъма по-горе. Конвенцията името на функцията да започва с "главна буква" е за да стане ясно, че функция трябва да се изпълнява с оператора `new`.

````smart header="new function() { ... }"
Ако имаме много редове от код за създаване на един сложен обект, можем да ги обгърнем в конструкторска функция, като тази:

```js
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...друг код за създаване на потребител
  // може би сложна логика и определение
  // локални променливи и други
};
```

Конструкторът не може да бъде извикан отново, тъй като не е записан никъде, в дадения момент е създаден и извикан. Така че този трик има за цел да капсулира кода, който изгражда единичния обект, без бъдещо повторно използване.
````

## Тест за вида на конструктора: new.target

```smart header="Материал за напреднали"
Синтаксисът от този раздел се използва рядко, пропуснете го, освен ако не искате да знаете всичко.
```

Вътре във функцията, можем да проверим дали функцията е била извикана с `new` или без, използвайки специалното свойство `new.target`.

Тя е празна за обикновенни извиквания и се равнява на функцията, ако се извиква с `new`:

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Това може да се използва във функцията, за да се знае дали е извикана с `new`, "с конструктор метода", или без, "с обикновенния метод".

Можем да направим и двете `new` и обикновенните извиквания да направят едно и също, като тук:

```js run
function User(name) {
  if (!new.target) { // ако ме изпълните без new
    return new User(name); // ...Аз ще ви я добавя за вас
  }

  this.name = name;
}

let john = User("John"); // пренасочва извикванетоп към new User
alert(john.name); // John
```

Този подход понякога се използва в библиотеките, за да направи синтаксиса по-гъвкав. За да могат хората да извикат функцията със или без `new`, и то все още да работи.

Вероятно не е хубаво нещо да се използва навсякъде, защото пропускането на `new` прави по-малко очевидно какво се случва. С `new` всички знаем, че е създаден нов обект.

## Връщане от конструктори

Обикновенно, конструкторите нямат `return` декларация. Тяхната задача е да запишат всички необходими неща в `this`, и автоматично да станат резултат.

Но ако има `return` декларация, тогава правилото е просто:

- Ако `return` е извикано с обект, тогава обектът е върнат вместо `this`.
- Ако `return` е извикано с примитивно, то се игнорира.

С други думи, `return` в обект връща този обект, при всички други случаи се връща `this` .

Например, тук `return` заменя `this` чрез връщане на обект:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- връща този обект
}

alert( new BigUser().name );  // Godzilla, имаме този обект
```

И ето пример с празен `return` (или бихме могли да поставим примитивен след него, но няма значение):

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- връща this
}

alert( new SmallUser().name );  // John
```

Обикновено конструкторите нямат декларацията `return`.Тук споменаваме специалното поведение с връщането на обекти главно в името на цялостността на ръководството.

````smart header="Пропускане на скоби"
Между другото, можем да пропуснем скобите след `new`, ако нямаме аргументи:

```js
let user = new User; // <-- няма скоби
// same as
let user = new User();
```

Пропускането на скоби тук не се счита за "добър стил", но синтаксисът разрешава по спецификацията.
````

## Методи в конструктора

Използването на конструкторски функции за създаване на обекти дава голяма доза гъвкавост. Конструкторската функция може да има параметри, които определят как да конструираме обекта и какво да поставим в него.

Разбира се, можем да добавим към `this` не само свойства, но и функции.

Например, `new User(name)` по-долу създава обект с даденото `name` и функции `sayHi`:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

*!*
let john = new User("John");

john.sayHi(); // My name is: John
*/!*

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

За създаване на сложни обекти, има по-напреднал синтаксис, т.нар. [Класове](info:classes), ще ги покрием по-късно.

## Обобщение

- Конструкторски функции, или накратко конструкторите, са обикновенни функции, но има общо споразумение за преименувамето им с главна буква.
- Конструкторските функции  трябва да се извикват само с помощта на оператора `new`. Подобно извикване предполага създаване на празен `this` в началото и връщането на попълнения в края.

Можем да използваме конструкторски функции, за да направим множество подобни обекти.

JavaScript осигурява конструкторски функции за много вградени езикови обекти: като `Date` за дати, `Set` за множества и други, които планираме да изучим.

```smart header="Ще се върнем на обектите!"
В тази глава обхващаме само основите за обектите и конструкторите. Те са от съществено значение за научаването на повече за типовете данни и функциите в следващите глави.

След като научихме тези, ще се върнем към обектите и ще ги покриваме задълбочено в главите <info:prototypes> и <info:classes>.
```
