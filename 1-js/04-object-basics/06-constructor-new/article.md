# Конструктор, операторът "new"

<<<<<<< HEAD
Обикновения синтаксис с `{...}` позволява да се създаде един обект. Но често трябва да създаваме много подобни обекти, като множество потребители или елементи от менюто и т.н.
=======
The regular `{...}` syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
>>>>>>> e2f9e5840737e00846bfd492192d8a3828820c60

Това може да стане с помощта на конструкторски функции и с оператора `"new"`.

## Функция на конструктора

Конструкторските функции технически са обикновенни функции. Обаче има две конвенции:

1. Те са кръстени с главна буква.
2. Те трябва да бъдат изпълнени само с `"new"` оператора.

Например:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

Когато функцията се изпълнява с `new`, тя прави следните стъпки:

1. Създава се и се присвоява нов празен обект към `this`.
2. Тялото на функцията се изпълнява. То обикновено модифицира `this` като добавя нови свойства към него.
3. Стойността на `this` се връща.

С други думи, `new User(...)` прави нещо подобно:

```js
function User(name) {
*!*
  // this = {};  (имплицитно)
*/!*

  // добавя свойства на this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (имплицитно)
*/!*
}
```

Кодът `let user = new User("Jack")` дава същия резултат като на:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

Сега ако искаме да създадем други потребители можем просто да извикваме `new User("Ann")`, `new User("Alice")` и т.н. . Много по-кратко от използването на литерали всеки път, а също и лесен за четене.

Това е основната цел на конструктора -- да имплементира преизползваем код за създаване на обекти

<<<<<<< HEAD
Нека да отбележим още веднъж -- технически всяка функция може да се използва като конструктор. Това е: всяка функция може да се изпълни с `new`, и то ще изпълни алгоритъма по-горе. Конвенцията името на функцията да започва с "главна буква" е за да стане ясно, че функция трябва да се изпълнява с оператора `new`.

````smart header="new function() { ... }"
Ако имаме много редове от код за създаване на един сложен обект, можем да ги обгърнем в конструкторска функция, като тази:
=======
Let's note once again -- technically, any function (except arrow functions, as they don't have `this`) can be used as a constructor. It can be run with `new`, and it will execute the algorithm above. The "capital letter first" is a common agreement, to make it clear that a function is to be run with `new`.

````smart header="new function() { ... }"
If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:
>>>>>>> 8558fa8f5cfb16ef62aa537d323e34d9bef6b4de

```js
// create a function and immediately call it with new
let user = new function() { 
  this.name = "John";
  this.isAdmin = false;

  // ...друг код за създаване на потребител
  // може би сложна логика и определение
  // локални променливи и други
};
```

<<<<<<< HEAD
Конструкторът не може да бъде извикан отново, тъй като не е записан никъде, в дадения момент е създаден и извикан. Така че този трик има за цел да капсулира кода, който изгражда единичния обект, без бъдещо повторно използване.
=======
This constructor can't be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.
>>>>>>> 8558fa8f5cfb16ef62aa537d323e34d9bef6b4de
````

## Тест за вида на конструктора: new.target

```smart header="Материал за напреднали"
Синтаксисът от този раздел се използва рядко, пропуснете го, освен ако не искате да знаете всичко.
```

Вътре във функцията, можем да проверим дали функцията е била извикана с `new` или без, използвайки специалното свойство `new.target`.

<<<<<<< HEAD
Тя е празна за обикновенни извиквания и се равнява на функцията, ако се извиква с `new`:
=======
It is undefined for regular calls and equals the function if called with `new`:
>>>>>>> f6ae0b5a5f3e48074312ca3e47c17c92a5a52328

```js run
function User() {
  alert(new.target);
}

// без "new":
*!*
User(); // undefined
*/!*

// с "new":
*!*
new User(); // function User { ... }
*/!*
```

Това може да се използва във функцията, за да се знае дали е извикана с `new`, "с конструктор метода", или без, "с обикновенния метод".

Можем да направим и двете `new` и обикновенните извиквания да направят едно и също, като тук:

```js run
function User(name) {
  if (!new.target) { // ако ме изпълните без new
    return new User(name); // ...Аз ще ви я добавя за вас
  }

  this.name = name;
}

let john = User("John"); // пренасочва извикванетоп към new User
alert(john.name); // John
```

Този подход понякога се използва в библиотеките, за да направи синтаксиса по-гъвкав. За да могат хората да извикат функцията със или без `new`, и то все още да работи.

Вероятно не е хубаво нещо да се използва навсякъде, защото пропускането на `new` прави по-малко очевидно какво се случва. С `new` всички знаем, че е създаден нов обект.

## Връщане от конструктори

Обикновенно, конструкторите нямат `return` декларация. Тяхната задача е да запишат всички необходими неща в `this`, и автоматично да станат резултат.

Но ако има `return` декларация, тогава правилото е просто:

- Ако `return` е извикано с обект, тогава обектът е върнат вместо `this`.
- Ако `return` е извикано с примитивно, то се игнорира.

С други думи, `return` в обект връща този обект, при всички други случаи се връща `this` .

Например, тук `return` заменя `this` чрез връщане на обект:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- връща този обект
}

alert( new BigUser().name );  // Godzilla, имаме този обект
```

И ето пример с празен `return` (или бихме могли да поставим примитивен след него, но няма значение):

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- връща this
}

alert( new SmallUser().name );  // John
```

Обикновено конструкторите нямат декларацията `return`.Тук споменаваме специалното поведение с връщането на обекти главно в името на цялостността на ръководството.

````smart header="Пропускане на скоби"
Между другото, можем да пропуснем скобите след `new`, ако нямаме аргументи:

```js
let user = new User; // <-- няма скоби
// same as
let user = new User();
```

Пропускането на скоби тук не се счита за "добър стил", но синтаксисът разрешава по спецификацията.
````

## Методи в конструктора

Използването на конструкторски функции за създаване на обекти дава голяма доза гъвкавост. Конструкторската функция може да има параметри, които определят как да конструираме обекта и какво да поставим в него.

Разбира се, можем да добавим към `this` не само свойства, но и функции.

Например, `new User(name)` по-долу създава обект с даденото `name` и функции `sayHi`:

```js run
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

*!*
let john = new User("John");

john.sayHi(); // My name is: John
*/!*

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```

За създаване на сложни обекти, има по-напреднал синтаксис, т.нар. [Класове](info:classes), ще ги покрием по-късно.

## Обобщение

- Конструкторски функции, или накратко конструкторите, са обикновенни функции, но има общо споразумение за преименувамето им с главна буква.
- Конструкторските функции  трябва да се извикват само с помощта на оператора `new`. Подобно извикване предполага създаване на празен `this` в началото и връщането на попълнения в края.

Можем да използваме конструкторски функции, за да направим множество подобни обекти.

JavaScript осигурява конструкторски функции за много вградени езикови обекти: като `Date` за дати, `Set` за множества и други, които планираме да изучим.

```smart header="Ще се върнем на обектите!"
В тази глава обхващаме само основите за обектите и конструкторите. Те са от съществено значение за научаването на повече за типовете данни и функциите в следващите глави.

След като научихме тези, ще се върнем към обектите и ще ги покриваме задълбочено в главите <info:prototypes> и <info:classes>.
```
