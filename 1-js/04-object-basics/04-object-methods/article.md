# Методи на обекта, "this"

Обектите обикновено се създават, за да представят реално съществуващи неща, като потребители, поръчки и т.н.:

```js
let user = {
  name: "John",
  age: 30
};
```

И в реалния свят потребителят може да *извършва действия*: да селектира нещо от онлайн количката за пазаруване, да се логва, разлогва и др.

Действията в JavaScript са предсавени чрез функции в пропъртита/свойства.

## Примерни методи

За начало, нека научим `потребителя` да казва здравей:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

Тук ние току-що използвахме функционален израз, за да създадем функция и да я подадем на пропъртито (свойството) `user.sayHi` на обекта.

След това може да я извикаме. Сега потребителят може да говори!

Функция, която е свойство на обект, се нарича *метод* на обекта.

И така ние имаме метод `sayHi` на обекта `user`.

Разбира се, ние можем да използваме пре-декларирана функция като метод, ето така:

```js run
let user = {
  // ...
};

*!*
// първо декларираме функцията
function sayHi() {
  alert("Hello!");
}

// После я добавяме като метод
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="Обектно-ориентирано програмиране"
Когато пишем нашия код използвайки обекти, за да представим реално съществуващи неща, това се нарича [обектно-ориентирано програмиране](https://en.wikipedia.org/wiki/Object-oriented_programming), накратко: "OOП".

OOП е нещо голямо, една изключително интересна наука сама по себе си. Как да изберем правилните обекти? Как да организираме взаимодействието между тях? Това е архитектура и има много книги, написани по този въпрос, като "Design Patterns: Elements of Reusable Object-Oriented Software" от E. Gamma, R. Helm, R. Johnson, J. Vissides или "Object-Oriented Analysis and Design with Applications" от G. Booch, и още.
```
### Method shorthand

Има и по-кратък начин да се пишат методи в обектен литерал:

```js
// Тези обекти правят едно и също нещо

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// Краткият начин изглежда по-добре, нали?
user = {
*!*
<<<<<<< HEAD
  sayHi() { // също като "sayHi: function()"
=======
  sayHi() { // same as "sayHi: function(){...}"
>>>>>>> 6ab384f2512902d74e4b0ff5a6be60e48ab52e96
*/!*
    alert("Hello");
  }
};
```

Както видяхме, може да пропуснем `"function"` и да напишем само `sayHi()`.

<<<<<<< HEAD
В действителност тези нотации не са напълно идентични. Има леки различия, свързани с обектното унаследяване (ще бъде рязгледано по-късно), но за сега това няма значение. В почти всеки случай се предпочита краткият синтаксис.
=======
To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.
>>>>>>> 7000ede297bfd688f9a3767e8ca43abd9242f322

## "this" в методите

Методът на обекта иска да достъпи информацията, която се съхранява в обекта, за да си свърши работата.

Например, кодът вътре в `user.sayHi()` може да има нужда от името на `user`.

**За да достъпи обекта, методът може да използва ключовата дума `this`.**

Стойността на `this` е обектът "преди точката", този, който се използва, за да се извика метода.

Например:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" е "текущият обект"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

Тук по време на изпълнението на `user.sayHi()`, стойността на `this` ще бъде `user`.

Технически е възможно да достъпим обекта и без `this`, като го реферираме през външната променлива:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // "user" вместо "this"
*/!*
  }

};
```

...Но този код не е надежден. Ако решим да копираме `user` в друга променлива, пр. `admin = user` и презапишем `user` с нещо друго, тогава ще достъпим грешния обект.

Това е показано долу:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // води към грешка
*/!*
  }

};


let admin = user;
user = null; // презаписваме за да направим нещата по-ясни

*!*
admin.sayHi(); // TypeError: Cannot read property 'name' of null
               // TypeError: Не може да се прочете свойството 'name' на null
*!*
```

Ако използвахме `this.name` вместо `user.name` вътре в `alert`, кодът щеше да работи.

## "this" не е обвързан

В JavaScript, ключовата дума `this` се държи различно в сравнение с повечето програмни езици. Тя може да се използва във всяка функция, дори ако не е метод на обекта.

Няма синтактична грешка в следващия пример:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

Стойността на `this` се изчислява по време на изпълнение на кода в зависимост от контекста. 

Например тук една и съща функция е  присвоена на два различни обекта и има различни "this" по време на извикване:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// Използваме една и съща функция в два обекта
user.f = sayHi;
admin.f = sayHi;
*/!*

// тези извиквания имат различни this
// "this" вътре във функцията е обекта "преди точката"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (точка или квадратни скоби достъпва метода – няма значение)
```

Правилото е просто: ако извикаме `obj.f()`, тогава `this` е `obj` по време на извикването от `f`. Така че това е или `user` или `admin` в горния пример.

````smart header="Извикване без обект: `this == undefined`"
Ние може да извикаме функцията дори без обекта:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

В този случай `this` е `undefined` в стриктен режим. Ако опитаме да достъпим `this.name`, ще има грешка.

В нестриктен режим стойността на `this` в този случай ще бъде *глобалният обект* (`window` в браузъра, ще го разгледаме по-нататък в главата [](info:global-object)). Това е историческо поведение, което `"use strict"` оправя.

Обикновено такова извикване е грешка на програмиста. Ако има `this` вътре във функция, то очаква да бъде извикано в контекста на обект.
````

```smart header="Последиците от свободен `this`"
Ако идвате от друг програмен език вероятно сте запознати с идеята за "обвързан `this`", където методите, дефинирани в един обект, винаги имат `this`, което реферира този обект.

В JavaScript `this` е "свободен", неговата стойност се изчислява по време на извикване и не зависи от това къде е дефиниран метода, а от това кой е обекта "преди точката".

Концепцията за `this`, който се изчислява по време на изпълнение на кода има както плюсове, така и минуси. От една страна функцията може да се преизползва за други обекти. От друга страна голямата гъвкавост създава повече възможности за грешка. 

Нашата позиция тук не е да отсъдим дали този дизайн на езика е добър или лош. Ние ще обясним как да работите с него, как да извличате ползите и да избягвате проблеми. 
```

## Arrow функциите нямат "this"

Arrow функциите са специални: те нямат "собствен" `this`. Ако реферираме `this` от такава функция, той се взима от външната "нормална" функция.

Например, тук `arrow()` използва `this` от външният `user.sayHi()` метод:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

Това е специално свойство на arrow функциите, използва се когато не искаме да имаме отделен `this`, а вместо това да го вземем от външния коитекст. По-късно в главата <info:arrow-functions> ще разгледаме подробно arrow функциите.


## Обобщение

- Функции, които се намират в пропъртита на обекти, се наричат "методи".
- Методите позволяват на обектите да "извършват действия" като `object.doSomething()`.
- Методите могат да реферират обекта с ключовата дума `this`.

Стойността на `this` се определя по време на изпълнението на кода.
- Когато декларираме функция, тя може да използва `this`, но това  `this` няма да има стойност докато не извикаме функцията.
- Една функция може да се копира между обекти.
- Когато функция е извикана чрез следния "метод" синтаксис: `object.method()`, стойността на `this` по време на извикването е `обект`.

Имайте предвид, че arrow функциите са специални: те нямат `this`. Когато използваме `this` в arrow функция, неговата стойност се взима отвън.
