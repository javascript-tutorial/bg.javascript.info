# Методи на обекта, "this"

Обектите обикновено се създават, за да представят реално съществуващи неща, като потребители, поръчки и т.н.:

```js
let user = {
  name: "John",
  age: 30
};
```

И в реалния свят потребителят може да *извършва действия*: да селектира нещо от онлайн количката за пазаруване, да се логва, разлогва и др.

Действията в JavaScript са предсавени чрез функции в пропъртита/свойства.

## Примерни методи

За начало, нека научим `потребителя` да казва здравей:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

Тук ние току-що използвахме функционален израз, за да създадем функция и да я подадем на пропъртито (свойството) `user.sayHi` на обекта.

След това може да я извикаме. Сега потребителят може да говори!

Функция, която е свойство на обект, се нарича *метод* на обекта.

И така ние имаме метод `sayHi` на обекта `user`.

Разбира се, ние можем да използваме пре-декларирана функция като метод, ето така:

```js run
let user = {
  // ...
};

*!*
// първо декларираме функцията
function sayHi() {
  alert("Hello!");
};

// После я добавяме като метод
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="Обектно-ориентирано програмиране"
Когато пишем нашия код използвайки обекти, за да представим реално съществуващи неща, това се нарича [обектно-ориентирано програмиране](https://en.wikipedia.org/wiki/Object-oriented_programming), накратко: "OOП".

OOП е нещо голямо, една изключително интересна наука сама по себе си. Как да изберем правилните обекти? Как да организираме взаимодействието между тях? Това е архитектура и има много книги, написани по този въпрос, като "Design Patterns: Elements of Reusable Object-Oriented Software" от E. Gamma, R. Helm, R. Johnson, J. Vissides или "Object-Oriented Analysis and Design with Applications" от G. Booch, и още.
```
### Method shorthand

Има и по-кратък начин да се пишат методи в обектен литерал:

```js
// Тези обекти правят едно и също нещо

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// Краткият начин изглежда по-добре, нали?
user = {
*!*
  sayHi() { // също като "sayHi: function()"
*/!*
    alert("Hello");
  }
};
```

Както видяхме, може да пропуснем `"function"` и да напишем само `sayHi()`.

В действителност тези нотации не са напълно идентични. Има леки различия, свързани с обектното унаследяване (ще бъде рязгледано по-късно), но за сега това няма значение. В почти всеки случай се предпочита краткият синтаксис.

## "this" в методите

Методът на обекта иска да достъпи информацията, която се съхранява в обекта, за да си свърши работата.

Например, кодът вътре в `user.sayHi()` може да има нужда от името на `user`.

**За да достъпи обекта, методът може да използва ключовата дума `this`.**

Стойността на `this` е обектът "преди точката", този, който се използва, за да се извика метода.

Например:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" е "текущият обект"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

Тук по време на изпълнението на `user.sayHi()`, стойността на `this` ще бъде `user`.

Технически е възможно да достъпим обекта и без `this`, като го реферираме през външната променлива:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // "user" вместо "this"
*/!*
  }

};
```

...Но този код не е надежден. Ако решим да копираме `user` в друга променлива, пр. `admin = user` и презапишем `user` с нещо друго, тогава ще достъпим грешния обект.

Това е показано долу:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // води към грешка
*/!*
  }

};


let admin = user;
user = null; // презаписваме за да направим нещата по-ясни

admin.sayHi(); // Опа! Вътре в sayHi(), се използва старото име! Грешка!
```

Ако използвахме `this.name` вместо `user.name` вътре в `alert`, кодът щеше да работи.

## "this" не е обвързан

В JavaScript, ключовата дума `this` се държи различно в сравнение с повечето програмни езици. Тя може да се използва във всяка функция.

Няма синтактична грешка в следващия пример:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

Стойността на `this` се изчислява по време на изпълнение на кода в зависимост от контекста. 

Например тук една и съща функция е  присвоена на два различни обекта и има различни "this" по време на извикване:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// Използваме една и съща функция в два обекта
user.f = sayHi;
admin.f = sayHi;
*/!*

// тези извиквания имат различни this
// "this" вътре във функцията е обекта "преди точката"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (точка или квадратни скоби достъпва метода – няма значение)
```

Правилото е просто: ако извикаме `obj.f()`, тогава `this` е `obj` по време на извикването от `f`. Така че това е или `user` или `admin` в горния пример.

````smart header="Извикване без обект: `this == undefined`"
Ние може да извикаме функцията дори без обекта:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

В този случай `this` е `undefined` в стриктен режим. Ако опитаме да достъпим `this.name`, ще има грешка.

В нестриктен режим стойността на `this` в този случай ще бъде *глобалният обект* (`window` в браузъра, ще го разгледаме по-нататък в главата [](info:global-object)). Това е историческо поведение, което `"use strict"` оправя.

Обикновено такова извикване е грешка на програмиста. Ако има `this` вътре във функция, то очаква да бъде извикано в контекста на обект.
````

```smart header="Последиците от свободен `this`"
Ако идвате от друг програмен език вероятно сте запознати с идеята за "обвързан `this`", където методите, дефинирани в един обект, винаги имат `this`, което реферира този обект.

В JavaScript `this` е "свободен", неговата стойност се изчислява по време на извикване и не зависи от това къде е дефиниран метода, а от това кой е обекта "преди точката".

Концепцията за `this`, който се изчислява по време на изпълнение на кода има както плюсове, така и минуси. От една страна функцията може да се преизползва за други обекти. От друга страна голямата гъвкавост създава повече възможности за грешка. 

Нашата позиция тук не е да отсъдим дали този дизайн на езика е добър или лош. Ние ще обясним как да работите с него, как да извличате ползите и да избягвате проблеми. 
```

## Arrow функциите нямат "this"

Arrow функциите са специални: те нямат "собствен" `this`. Ако реферираме `this` от такава функция, той се взима от външната "нормална" функция.

Например, тук `arrow()` използва `this` от външният `user.sayHi()` метод:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

Това е специално свойство на arrow функциите, използва се когато не искаме да имаме отделен `this`, а вместо това да го вземем от външния коитекст. По-късно в главата <info:arrow-functions> ще разгледаме подробно arrow функциите.


## Обобщение

- Функции, които се намират в пропъртита на обекти, се наричат "методи".
- Методите позволяват на обектите да "извършват действия" като `object.doSomething()`.
- Методите могат да реферират обекта с ключовата дума `this`.

Стойността на `this` се определя по време на изпълнението на кода.
- Когато декларираме функция, тя може да използва `this`, но това  `this` няма да има стойност докато не извикаме функцията.
- Една функция може да се копира между обекти.
- Когато функция е извикана чрез следния "метод" синтаксис: `object.method()`, стойността на `this` по време на извикването е `обект`.

Имайте предвид, че arrow функциите са специални: те нямат `this`. Когато използваме `this` в arrow функция, неговата стойност се взима отвън.
