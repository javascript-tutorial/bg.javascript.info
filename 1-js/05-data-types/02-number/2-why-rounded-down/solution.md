Вътрешната десетична дроб на `6.35` е безкраен. Както винаги и в такива случай, тя се съхранява с загуба на точност.

Нека да видим:

```js run
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
```

Загубата на точност може да доведе както до увеличаване, така и до намаляване на числото. В този конкретен случай числото става малко по-малко, затова се закръгли надолу.

И какво за `1.35`?

```js run
alert( 1.35.toFixed(20) ); // 1.35000000000000008882
```

Тук загубата на точност направи номера малко по-голям, така че се закръгля нагоре.

**Как можем да отстраним проблема с `6.35` ако искаме то да бъде закръглено по правилния начин?**

Трябва да го приближим до цяло число преди закръглянето:

```js run
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
```

Забележете че `63.5` почти няма загуба на точност.Това е така, защото десетичната част `0.5` реално е `1/2`. Дроби, разделени на `2` са точно представени в двоичната система, затова сега можем да го закръглим:


```js run
<<<<<<< HEAD
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(закръглен) -> 6.4
=======
alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
>>>>>>> 5dff42ba283bce883428c383c080fa9392b71df8
```

